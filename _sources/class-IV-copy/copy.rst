..  Copyright (C)  Dave Parillo.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, and Preface,
    no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

.. index:: 
   pair: copy; constructor

Copying objects
===============
C++ is one of the few languages that provides precise control
over how memory is managed.
In C++11, every class is created with 5 special functions:

- destructor
- copy constructor
- move constructor
- copy assignment operator
- move assignment operator

In many classes, such as most of those written so far,
the compiler generated default versions work fine.
As we will see, sometimes you have to write them yourself.

Programmers have choices on how (or if) objects are copied and moved.
Whenever an object is passed by value to a function,
or returned by value from a function, a copy is implicitly performed:

.. code-block:: cpp

   std::vector<int> scores;
   auto avg = average (scores);  // a copy of scores is passed to average

Copy operations also occur in range-for loops:

.. code-block:: cpp

   for (const int value: scores)

Each member of ``scores`` is copied into ``value`` on each iteration.

Explicit copying can also be performed.
Whenever you have an existing object and use it to initialize
a new or existing object, the copy constructor is called:

.. code-block:: cpp

   std::vector<std::string> words;
   std::vector<std::string> w2 = words; // copy words into w2

Both explicit and implicit copies are controlled by 
a special constructor called the *copy constructor*.
Like other constructors,
the copy constructor is a member function with the same name as the class name.
The signature **must** be able to evaluate to this:

.. code-block:: cpp

   class_name ( const class_name & );

A copy constructor *may* take other parameters, but that is uncommon.
If there are other parameters, they **must all have defaults values defined**.
In general,
the default copy constructor generated by the compiler will suffice.
If the default creation is inhibited for any reason,
it is acceptable to explicitly declare the default constructor:

.. code-block:: cpp

   class_name ( const class_name & ) = default;

However the default copy constructor is created,
the behavior is the same: each class member is copied, in initialization order.

.. tabbed:: copy_construct_tab


   .. tab:: Copy constructor

      A simple class with a default and a copy constructor.

      .. code-block:: cpp

         struct A
         {
           int n;
           double d;

           // user defined default constructor
           A(int n = 0, double d = 1) 
             : n{n}
             , d{d}
           { }

           // user defined copy constructor
           A(const A& other) 
             : n{other.n}
             , d{other.d} 
           { }
         };

      In this case, the user defined copy constructor
      does what the default constructors would do.
      When that is the case, it's best not to redo the work of the compiler.

   .. tab:: Run It

      .. activecode:: ac_class_copy_and_default_constructor
         :language: cpp
         :compileargs: ['-Wall', '-Wextra', '-pedantic', '-std=c++11']
         :nocodelens:

         #include <iostream>

         struct A
         {
           int n;
           double d;

           // user defined default constructor
           A(int n = 0, double d = 1) 
             : n{n}
             , d{d}
           { 
             std::cout << "default A\n";
           }

           // user defined copy constructor
           A(const A& other) 
             : n{other.n}
             , d{other.d} 
           { 
             std::cout << "copy into A\n";
           }
         };

         int main() {
           A a;
           A b = a;
           return b.n;
         }



When objects manage their own resources,
simple member-wise assignment cannot be used.
Consider the following:

.. code-block:: cpp

   #include <cctype>
   #include <cstddef>
   #include <cstring>
   #include <iostream>

   namespace mesa {
     class string {
       private:
         char* data;
         size_t sz;

       public:
         explicit string(const char* value = "") {
           sz = std::strlen(value) + 1;
           data = new char[sz];
           for (size_t i=0; i < sz; ++i) {
            data[i] = value[i];
           }
           data[sz-1] = '\0';
         }
         void upper_case() {
           for (size_t i=0; i < sz; ++i)
            data[i] = std::toupper(data[i]);
         }

         ~string() {
           delete[] data;
         }

         char* c_str() { return data; }
     };

   } // namespace mesa


This class encapsulates an array of characters, providing 4 functions:

- A one arg constructor that also serves as the default constructor
  The constructor allocates memory for the ``char`` array and copies
  the provided string
- A destructor to clean up memory allocated by the constructor
- A function ``upper`` to transform the entire array to upper case.

.. tabbed:: shallow_copy_tab

   .. tab:: Using mesa::string

      What happens when we use this class?

      .. code-block:: cpp

         int main() {
           mesa::string hello("Hello, world!");
           mesa::string copy = hello;
           copy.upper_case();
           std::cout << hello.c_str() << '\n';
           std::cout << copy.c_str() << '\n';

           return 0;
         }

   .. tab:: Run It

      .. activecode:: ac_shallow_copy_string_class
         :language: cpp
         :compileargs: ['-Wall', '-Wextra', '-pedantic', '-std=c++11']
         :nocodelens:

         #include <cctype>
         #include <cstddef>
         #include <cstring>
         #include <iostream>

         namespace mesa {
           class string {
             private:
               char* data;
               size_t sz;

             public:
               explicit string(const char* value = "") {
                 sz = std::strlen(value) + 1;
                 data = new char[sz];
                 for (size_t i=0; i < sz; ++i) {
                  data[i] = value[i];
                 }
                 data[sz-1] = '\0';
               }
               void upper_case() {
                 for (size_t i=0; i < sz; ++i)
                  data[i] = std::toupper(data[i]);
               }

               ~string() {
                 delete[] data;
               }

               char* c_str() { return data; }
           };

         } // namespace mesa

         int main() {
           mesa::string hello("Hello, world!");
           mesa::string copy = hello;
           copy.upper_case();
           std::cout << hello.c_str() << '\n';
           std::cout << copy.c_str() << '\n';

           return 0;
         }

      Even though we copied ``hello``,
      changing the case of copy also resulted in changes to the original.
      When we copy a value, we expect a *cloned object*.
      A object that in all respects has the same attributes,
      but that is separate and distinct.
      We **don't** want changes in one to affect the other.

   .. tab:: Code Lens

      The default copy behavior is a *shallow copy*:
      a literal copying of the bytes of each member variable.
      In the case of our string class, the ``char*`` is faithfully copied.
      When the copy is made, both variables point to the same memory.

      .. codelens:: codelens_shallow_copy_string_class
         :language: cpp

         #include <cctype>
         #include <cstddef>
         #include <cstring>
         #include <iostream>

         namespace mesa {
           class string {
             private:
               char* data;
               size_t sz;

             public:
               explicit string(const char* value = "") {
                 sz = std::strlen(value) + 1;
                 data = new char[sz];
                 for (size_t i=0; i < sz; ++i) {
                  data[i] = value[i];
                 }
                 data[sz-1] = '\0';
               }
               void upper_case() {
                 for (size_t i=0; i < sz; ++i)
                  data[i] = std::toupper(data[i]);
               }

               ~string() {
                 delete[] data;
               }

               char* c_str() { return data; }
           };

         } // namespace mesa

         int main() {
           mesa::string hello("Hello, world!");
           mesa::string copy = hello;
           copy.upper_case();
           std::cout << hello.c_str() << '\n';
           std::cout << copy.c_str() << '\n';

           return 0;
         }


Because there are two pointers to the same data on the free store,
when either is deleted, the free-store memory is recovered.
Consider this:

.. code-block:: cpp

   mesa::string hello("Hello, world!");

   // create a new scope
   {
     mesa::string copy = hello;
   } // local variable copy destroyed

   std::cout << hello.c_str() << '\n';

What does the last line print?

.. reveal:: reveal_str_copy_ube

   There is no way to know for sure.

   When ``copy`` goes out of scope and its destructor is called,
   it deletes the memory ``copy::data`` points to,
   but this is the same array ``hello`` is using.
   When ``hello.c_str()`` is called, undefined behavior is the result.


Fixing these problems requires writing a custom copy constructor.

.. code-block:: cpp

   string (const string& other) {
     sz = other.sz;
     data = new char[sz];
     std::strcpy(data, other.data);
   }

Each class member needs to be copied.
The member ``sz`` can simply be default copied.
It's the pointer member that needs special treatment:

- Initialize a new memory block large enough to hold the copy
- Copy each element of the source array into the destination.
  This is what :cpp:`std::strcpy<string/byte/strcpy>` does.

In contrast to a *shallow* copy,
this copy is a **deep copy**.
It doesn't copy the pointer at all.
It makes an entirely new pointer and (deeply)
copies all of the data pointed to by the source pointer to the destination.

.. admonition:: Try This!

   Take the copy constructor provided and implement in the previous 
   ``mesa::string`` examples in this section.

-----

.. admonition:: More to Explore

   - From cppreference.com:

     - `Copy constructors <https://en.cppreference.com/w/cpp/language/copy_constructor>`__

