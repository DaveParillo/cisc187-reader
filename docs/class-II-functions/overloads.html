<!-- ****************************************
     |docname| - main template for this theme
     **************************************** -->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>8.3. Operator overloads &#8212; CISC 187 Course Reader Overview</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/accessibility.css?v=50109A2C" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css?v=58BC228F" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/637.0fa6cababf056764.css?v=F9484CEF" />
    <link rel="stylesheet" type="text/css" href="../_static/runestone.3eb60bc006ae9a54.css?v=3A5A250C" />



    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/animationbase.js?v=A043C3A7"></script>
    <script src="../_static/matrixeq.js?v=D64CFA5A"></script>
    <script src="../_static/runtime.66b619f51b746382.bundle.js?v=C3F69EE5"></script>
    <script src="../_static/637.d54be67956c5c660.bundle.js?v=915B1670"></script>
    <script src="../_static/runestone.ecc6dff5cad8b815.bundle.js?v=AE959292"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8.4. Friend vs non-friend functions" href="friend.html" />
    <link rel="prev" title="8.2. Static members" href="static.html" />


<link rel="shortcut icon" href="/cisc187-reader/static/favicon.ico" type="image/ico" />



<link rel="canonical" href="https://{{canonical_host}}{{new_server_prefix}}/books/published/{{base_course}}/{{pagepath}}" />


<script>
  eBookConfig = {};
  
    eBookConfig.useRunestoneServices = false;
    eBookConfig.host = 'https://daveparillo.github.io/cisc187-reader/' || 'http://127.0.0.1:8000';
    eBookConfig.app = eBookConfig.host+'/cisc187-reader';
    eBookConfig.course = 'cisc187-reader';
    eBookConfig.basecourse = 'cisc187-reader';
    eBookConfig.isLoggedIn = false;
    eBookConfig.enableCompareMe = eBookConfig.useRunestoneServices;
    eBookConfig.new_server_prefix = '';
  
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.python3 = true;
  eBookConfig.acDefaultLanguage = 'cpp' ? 'cpp' : 'python'
  eBookConfig.runestone_version = '6.6.2';
  eBookConfig.jobehost = 'https://delicate-frost-8843.fly.dev';
  eBookConfig.proxyuri_runs = '/jobe/index.php/restapi/runs/';
  eBookConfig.proxyuri_files = '/jobe/index.php/restapi/files/';
  eBookConfig.enable_chatcodes = false ? false : false;
  eBookConfig.enableScratchAC = true;

</script>

<!-- Ad Serving Headers Only serve ads to Anonymous Users -->



  </head><body>


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse" aria-label="navbar toggle">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        
        
          <div class="brand-logo"><img src="../_static/img/RAIcon.png" alt=""></div>
        
        <a class="navbar-brand" href="../index.html" aria-label="index-page">
          
          cisc187-reader
        </a>
      </div>
    </div>



    <div class="navbar-collapse collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right" >

        <li class="divider-vertical"></li>

        <!-- social media dropdown -->
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>
        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'><span class="visuallyhidden" aria-label="Search">Search</span></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='../index.html' aria-label="index-page">Table of Contents</a></li>
            
            <li><a href='../genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="../search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>
        <!-- <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li> -->

        <!-- <li class="dropdown">             -->
          <li id="scratch_ac_link" class="dropdown"><a href="javascript:runestoneComponents.popupScratchAC()">
              <i class="glyphicon glyphicon-pencil" style="opacity:0.9;"><span class="visuallyhidden" aria-label="Scratch Activecode" >Scratch Activecode</span></i></a></li>
        <!-- </li> -->

        <li class="divider-vertical"></li>

        
      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        
          
          <li class="divider-vertical"></li>
        
        <!-- 
          
  <li id="relations-prev" title="Previous Chapter - <span class="section-number">8.2. </span>Static members" data-toggle="tooltip">
    <a href="static.html" >
      <i class='glyphicon glyphicon-backward' style='opacity:0.9;'></i>
    </a>
  </li>
  
  <li id="relations-next" title='Next Chapter - <span class="section-number">8.4. </span>Friend vs non-friend functions' data-toggle="tooltip" >              
    <a href="friend.html" >
        <i class='glyphicon glyphicon-forward' style='opacity:0.9;'></i>
    </a>
  </li>
  <li class="divider-vertical"></li>

<script>
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  window.addEventListener('load', (event) => {
    $('#relations-prev').tooltip(opts);
    $('#relations-next').tooltip(opts);
  });
</script>
        -->
        
          <li></li>
        
      </ul>
      </div> <!-- navbar-collapse -->
    </div> <!-- navbar -->
  </div> <!-- container -->


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content" role="main">

<!-- Ad Serving for Runestone Campaign -->


  
  <section id="operator-overloads">
<span id="index-0"></span><h1><span class="section-number">8.3. </span>Operator overloads<a class="headerlink" href="#operator-overloads" title="Permalink to this heading">¶</a></h1>
<p>There are many reasons to want to overload the builtin operator
functions for user defined types.</p>
<p><strong>Case 1</strong></p>
<p>Operator overloads are <em>required</em> for some containers in the STL.
Notably <a class="reference external" href="https://en.cppreference.com/w/cpp/container/set">set</a>,
which requires any type used in a set overloads <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code>,
or the operator defined for the set if a custom comparison
function is defined.
Similarly, <a class="reference external" href="https://en.cppreference.com/w/cpp/container/map">map</a> requires <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code>
and <a class="reference external" href="https://en.cppreference.com/w/cpp/container/unordered_map">unordered_map</a> requires both that and <code class="docutils literal notranslate"><span class="pre">operator==</span></code>.</p>
<p>Classes that do not overload these comparison operators
can’t be used in these containers.</p>
<p>Overloading these operators is useful in any conditional expression,
but only makes sense when creating a class
with data members that are <em>comparable</em>.</p>
<p><strong>Case 2</strong></p>
<p>C++ provides many builtin types and operators to manipulate them.
We want new user defined types to be as simple and intuitive to use as
the builtin types.</p>
<p>For example, finding the roots of a quadratic equation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">root1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">)))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>When all the variables are builtin types,
this looks familiar.
But without operator overloads, a rational number class
would be a pain to read and use.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w">  </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Rational</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="n">Rational</span><span class="w"> </span><span class="n">b</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">Rational</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Rational</span><span class="w"> </span><span class="n">c</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">Rational</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="n">Complex</span><span class="w"> </span><span class="n">tmp</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">                      </span><span class="p">.</span><span class="n">minus</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">))));</span>
<span class="n">root</span><span class="p">.</span><span class="n">setComplex</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">invSign</span><span class="p">().</span><span class="n">plus</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">))));</span>
</pre></div>
</div>
<p>When <em>everything</em> has to be a named function,
and the standard operators can only be used on builtin types,
the result is not as clean as we would like.</p>
<p>What we want here is the ability to use familiar semantics
on user defined types.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rational</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="n">b</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">c</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="n">root1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">)))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>Overloading the standard operator functions
make this possible.</p>
<p>In C++, operators are overloaded in the form of functions with special names.
For example, <code class="docutils literal notranslate"><span class="pre">a+b</span></code> and <code class="docutils literal notranslate"><span class="pre">operator+(a,b)</span></code> both call
the same function.</p>
<p>As with other functions,
overloaded operators can generally be implemented either as a member
function of their left operand’s type or as non-member functions.</p>
<p>Most of the work in overloading operators is boiler-plate code.
Not surprising,
since most operators defer their actual work to plain functions.
The programming community has already thought long and hard on
techniques to make overloads efficient and easy to maintain.</p>
<section id="basic-overloading-guidelines">
<span id="index-1"></span><h2><span class="section-number">8.3.1. </span>Basic overloading guidelines<a class="headerlink" href="#basic-overloading-guidelines" title="Permalink to this heading">¶</a></h2>
<p>Most C++ operators can be overloaded.
You cannot change the meaning of operators for built-in types in C++.
Operators can only be overloaded when at least 1 operand is a user-defined type.
Other rules of overloads still apply:
overloads for a specific function signature can only be used once.</p>
<p>Not all operators can be overloaded in C++.
Those that cannot be overloaded are:
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">::</span></code>,
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">sizeof</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">typeid</span></code>,
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">.*</span></code>, and <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">?</span> <span class="pre">:</span></code>.</p>
<p>When it comes to operator overloading in C++,
there are basic guidelines you should follow.
As with all such guidelines, there are exceptions.
The goal of operator overloading is to make classes <em>easier</em>
to use and to make them behave more like builtin types.
Keep that in mind when overloading.</p>
<ol class="arabic">
<li><p>Whenever the meaning of an operator is not obviously clear and undisputed,
it should not be overloaded.</p>
<p>Instead, provide a function with a well-chosen name.
It is hard to understand the semantics behind the
operator unless the use of the operator in the application
domain is well known and undisputed.
Contrary to popular belief, this is hardly ever the case.</p>
</li>
<li><p>Always stick to the well-known semantics for the operator.</p>
<p>C++ poses no limitations on the semantics of overloaded operators.
Your compiler will happily accept code that implements the binary + operator to
subtract from its right operand.
However, the users of such an operator would never suspect the expression a + b
to subtract a from b.
Of course, this supposes that the semantics of the operator in the application
domain is undisputed.</p>
</li>
<li><p>Always provide all out of a set of related operations.</p>
<p>Operators are related to each other and to other operations.</p>
<ul class="simple">
<li><p>If your type supports <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>,
then users will expect to be able to call <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">b</span></code>, too.</p></li>
<li><p>If it supports prefix increment <code class="docutils literal notranslate"><span class="pre">++a</span></code>,
then <code class="docutils literal notranslate"><span class="pre">a++</span></code> is likely expected also.</p></li>
<li><p>If they can check whether <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>,
then most users expect to also to be able to check <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>.</p></li>
<li><p>If copy-construction is allowed, then assignment is expected.</p></li>
</ul>
</li>
</ol>
<p>The remaining sections describe the specific techniques and
function signatures for some of the most common operator overloads.</p>
</section>
<section id="assignment-operator">
<h2><span class="section-number">8.3.2. </span>Assignment operator<a class="headerlink" href="#assignment-operator" title="Permalink to this heading">¶</a></h2>
<p>The copy assignment operator is called when an object appears
on the left side of an assignment expression.</p>
<p>The canonical copy-assignment operator is expected to perform
no action on self-assignment, and to return the <code class="docutils literal notranslate"><span class="pre">lhs</span></code> by reference:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// copy data from other to</span>
<span class="w">  </span><span class="c1">// current instance</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In those situations where copy assignment cannot benefit from resource reuse
(it does not manage a heap-allocated array and does not have a
member that does, such as a member std::vector or std::string),
there is a popular convenient shorthand:
the copy-and-swap assignment operator,
which takes its parameter by value
swaps with the parameter, and lets the destructor clean it up.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// copy/move constructor is called to construct other</span>
<span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span><span class="w"> </span><span class="c1">// exchange resources between *this and other</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When the function ends,
the destructor of <code class="docutils literal notranslate"><span class="pre">other</span></code> is called to release the resources
formerly held by <code class="docutils literal notranslate"><span class="pre">*this</span></code>.
A custom swap function for the user defined type <code class="docutils literal notranslate"><span class="pre">T</span></code>
is required for this technique to work:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">friend</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">second</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// by swapping the members of two objects,</span>
<span class="w">  </span><span class="c1">// the two objects are effectively swapped</span>
<span class="w">  </span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">size_</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">.</span><span class="n">size_</span><span class="p">);</span>
<span class="w">  </span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">value_</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">.</span><span class="n">value_</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// repeat for each member</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="insertion-and-extraction-operators">
<h2><span class="section-number">8.3.3. </span>Insertion and extraction operators<a class="headerlink" href="#insertion-and-extraction-operators" title="Permalink to this heading">¶</a></h2>
<p>The bitshift operators <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>,
although still used in hardware interfacing for the bit-manipulation functions
they inherit from C,
have become more prevalent as formatted stream operators in C++.</p>
<p>The overloads of <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">&lt;&lt;</span></code> that take a
<a class="reference external" href="https://en.cppreference.com/w/cpp/io/basic_istream">std::istream</a> reference or
<a class="reference external" href="https://en.cppreference.com/w/cpp/io/basic_ostream">std::ostream</a> reference as the left hand argument
are known as insertion and extraction operators.</p>
<p>Since these operators change their left argument (they alter the stream),
they should, according to the rules of thumb,
be implemented as members of their left operand’s type.
However, their left operands are streams from the standard library,
and while most of the stream output and input operators defined by the
standard library are indeed defined as members of the stream classes,
when you implement output and input operations for your own types,
you cannot change the standard library’s stream types.
So clearly, these overloads cannot be stream member functions.</p>
<p>It is common, however, to see C++ examples posted on the internet that
define these overloads as friends.
The advantage of making these functions friends is they have access
to the private data of the class, if needed.
The disadvantage of making these functions friends is that
you may decide to stream data out of a class that is otherwise
not accessible.</p>
<p>Why is that bad?</p>
<p>Josh Bloch in <em>Effective Java</em>, dedicates an entire section to this topic.
Effective Java discusses the <code class="docutils literal notranslate"><span class="pre">toString()</span></code> overload,
but it serves a similar purpose to <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">&lt;&lt;</span></code> in the Java language.</p>
<p>When you create
an output function that streams data out of your class
that is not available through any other function,
then some users will use your stream function just
to get their hands on your private data.</p>
<ul class="simple">
<li><p>If your data needs to be part of the output stream,
then make a function to access it.</p></li>
<li><p>If you have functions that provide access to every
private member that is part of the stream,
then you don’t need it to be a member function
or a <code class="docutils literal notranslate"><span class="pre">friend</span></code>.</p></li>
</ul>
<p>That’s why you need to implement these operators for your own types as
non-member non-friend functions. The canonical forms are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// write rhs to stream</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">is</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// read rhs from stream</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="cm">/* could not construct T from stream */</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">is</span><span class="p">.</span><span class="n">setstate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">failbit</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">is</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="function-call-operator">
<h2><span class="section-number">8.3.4. </span>Function call operator<a class="headerlink" href="#function-call-operator" title="Permalink to this heading">¶</a></h2>
<p>When a user-defined class overloads the function call operator,
<code class="docutils literal notranslate"><span class="pre">operator()</span></code>, it becomes a FunctionObject type.
A function object is a class that can be called as if it was a function.
Many standard algorithms, from <a class="reference external" href="https://en.cppreference.com/w/cpp/algorithm/sort`">sort`</a> to <a class="reference external" href="https://en.cppreference.com/w/cpp/algorithm/accumulate">accumulate</a>
accept objects of such types to customize behavior.
Prior to the C++11 additions of
<a class="reference external" href="https://en.cppreference.com/w/cpp/utility/functional/function">function</a> and lambda expressions,
function objects were an important way to pass functions to algorithms.</p>
<p>There are no particularly notable canonical forms of <code class="docutils literal notranslate"><span class="pre">operator()</span></code>,
but to illustrate the usage:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Sum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="n">Sum</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="n">Sum</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">Sum</span><span class="p">());</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike lambda expressions and function pointers,
when passing a function object to an algorithm,
the function call operator <strong>must</strong> be included.</p>
</div>
<p>A function call overload can be overloaded
to take any number of additional arguments, including zero.
A single class can contain more than 1 function call operator overload,
subject to the other rules of function overloading.</p>
</section>
<section id="relational-operators">
<h2><span class="section-number">8.3.5. </span>Relational operators<a class="headerlink" href="#relational-operators" title="Permalink to this heading">¶</a></h2>
<p>Standard algorithms such as std::sort and containers such as
<a class="reference external" href="https://en.cppreference.com/w/cpp/container/set">set</a> expect <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">&lt;</span></code> to be defined, by default,
for the user-provided types, and expect it to implement strict
<a class="reference external" href="http://en.cppreference.com/mwiki/index.php?search=std::weak_ordering">std::weak_ordering</a>.
Strict weak ordering defines members of a set as <em>comparable</em> to each other.
The general signature for these non-member functions is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">// compare the data in left-hand side and right-hand side objects</span>
<span class="w">   </span><span class="c1">// for less than</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">// compare the data in left-hand side and right-hand side objects</span>
<span class="w">   </span><span class="c1">// for equality</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An idiomatic way to implement strict weak ordering for a structure is to use
lexicographical comparison provided by <a class="reference external" href="https://en.cppreference.com/w/cpp/utility/tuple/tie">std::tie</a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Record</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">floor</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Record</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Record</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">// parameters passed to each tie must be in the same order</span>
<span class="w">   </span><span class="c1">// or this will always return false</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">floor</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
<span class="w">        </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">floor</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If some of the data required for the comparison is private
and has no function to access the data members,
then you may need to make your relational operators friends.</p>
<p>If you do need to define <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> as a member function,
then the left-hand side of the operator will be the this pointer.
The signature of the operator overload changes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">   </span><span class="cm">/* do actual comparison with *this */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that this form of the overload must be <code class="docutils literal notranslate"><span class="pre">const</span></code>
in order to compile as a member function.</p>
<p>Once you have defined <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">operator==</span></code>,
there is no need to rewrite the comparison logic again.
It is much better to implement the remaining comparison functions
in terms of <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// note the operands swapped inside the function body</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w">   </span><span class="n">rhs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lhs</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">lhs</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">lhs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">lhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since C++20, all 6 comparison operators are defined if the
three-way comparison operator <code class="docutils literal notranslate"><span class="pre">operator&lt;=&gt;</span></code> is defined,
and <em>that</em> operator, in turn, is generated by the compiler if it is
defined as defaulted:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Record</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">floor</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Record</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// records can now be compared with ==, !=, &lt;, &lt;=, &gt;, and &gt;=</span>
</pre></div>
</div>
</div>
</section>
<section id="binary-arithmetic-operators">
<h2><span class="section-number">8.3.6. </span>Binary arithmetic operators<a class="headerlink" href="#binary-arithmetic-operators" title="Permalink to this heading">¶</a></h2>
<p>Binary operators are typically implemented as non-members to maintain symmetry.
For example, when adding a complex number and an integer,
if <code class="docutils literal notranslate"><span class="pre">operator+</span></code> is a member function of the complex type,
then addition doesn’t behave in a way most people expect:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">complex</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="n">complex</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span><span class="w">  </span><span class="c1">// compiles</span>
<span class="n">complex</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">+</span><span class="n">a</span><span class="p">;</span><span class="w">  </span><span class="c1">// error</span>
</pre></div>
</div>
<p>As a member function, only complex+integer would compile, not integer+complex.
Since for every binary arithmetic operator there exists a corresponding
compound assignment operator,
canonical forms of binary operators are implemented in terms of their
compound assignments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">T</span>
<span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="c1">// compound assignment (does not need to be a member,</span>
<span class="w">  </span><span class="p">{</span><span class="w">                           </span><span class="c1">// but often is, to modify the private members)</span>
<span class="w">    </span><span class="c1">// add rhs to *this</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w">             </span><span class="c1">// return the result by reference</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The normal addition is often implemented as a non-friend non-member:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w">    </span><span class="c1">// passing lhs by value helps optimize chained a+b+c</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w">   </span><span class="c1">// passing lhs by non-const reference is acceptable</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">lhs</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span><span class="w"> </span><span class="c1">// reuse compound assignment</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">;</span><span class="w"> </span><span class="c1">// return the result by value (uses move constructor)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The remaining binary arithmetic operators are implemented using the same pattern.</p>
</section>
<section id="increment-and-decrement-operators">
<h2><span class="section-number">8.3.7. </span>Increment and decrement operators<a class="headerlink" href="#increment-and-decrement-operators" title="Permalink to this heading">¶</a></h2>
<p>Unlike many of the operator overloads in this section,
the increment and decrement operators are <em>unary</em> operators – only one
operand, the current object, is involved.</p>
<p>The postfix increment and decrement operator is usually implemented
in terms of the prefix version:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">T</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// prefix increment</span>
<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// do the actual increment here</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// postfix increment</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="nf">tmp</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy</span>
<span class="w">        </span><span class="k">operator</span><span class="o">++</span><span class="p">();</span><span class="w"> </span><span class="c1">// pre-increment</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w">   </span><span class="c1">// return old value</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are a couple of things to notice about postfix increment:</p>
<ul>
<li><p>It returns a constant copy of the previous object value.</p>
<p>Any modifications made to the returned object after calling <code class="docutils literal notranslate"><span class="pre">operator++(int)</span></code> would be
modifying a temporary object. This is always bad.
Returning a <code class="docutils literal notranslate"><span class="pre">const</span></code> object prevents accidental changes to a temporary object.
This overload should never return a reference.</p>
</li>
<li><p>It takes a ‘dummy parameter’ of type int.</p>
<p>The ‘dummy’ parameter simply allows two functions with the same name – <code class="docutils literal notranslate"><span class="pre">operator++</span></code>
to have different overloads and therefore different behaviors.
When the postfix increment and decrement appear in an expression,
the corresponding user-defined function (<code class="docutils literal notranslate"><span class="pre">operator++</span></code> or <code class="docutils literal notranslate"><span class="pre">operator--</span></code>)
is called with an integer argument 0.</p>
</li>
</ul>
</section>
<section id="conversion-operators">
<h2><span class="section-number">8.3.8. </span>Conversion operators<a class="headerlink" href="#conversion-operators" title="Permalink to this heading">¶</a></h2>
<p>C++ allows you to create operators to convert between your type and other ADT’s.
A conversion function is declared like a non-static member function or
member function template with</p>
<ul>
<li><p>no parameters,</p></li>
<li><p>no explicit return type, and</p></li>
<li><p>with the name of the form:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// implcit conversion</span>
<span class="k">operator</span><span class="w"> </span><span class="kt">int</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* return int version of type */</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// explicit conversion</span>
<span class="k">explicit</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="kt">int</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* return int version of type */</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Suppose we want to concatenate a Rational to a string?</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rational</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;A = &quot;</span><span class="p">};</span>
<span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">                   </span><span class="c1">// will not compile</span>
</pre></div>
</div>
<p>Your compiler may present something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>error: no viable overloaded &#39;+=&#39;
candidate function not viable:
no known conversion from &#39;Rational&#39; to
&#39;const std::__1::basic_string&lt;char&gt;&#39; for 1st argument
_LIBCPP_INLINE_VISIBILITY basic_string&amp; operator+=(const basic_string...
</pre></div>
</div>
<p>Defining a conversion operator for <code class="docutils literal notranslate"><span class="pre">std::string</span></code> allows this conversion
to happen:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rational</span><span class="o">::</span><span class="k">operator</span><span class="w"> </span><span class="nf">std::string</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">ss</span><span class="p">;</span>
<span class="w">   </span><span class="n">ss</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">numerator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">denominator</span><span class="p">;</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A class constructor taking a single argument can also be seen as
converting its argument into the type:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rational</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">   </span><span class="n">denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And an expression like this works:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rational</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>The conversion both of these previous cases,
for the <code class="docutils literal notranslate"><span class="pre">string</span></code> and the <code class="docutils literal notranslate"><span class="pre">int</span></code> happened implicitly.
Often, we don’t want types to <strong>always</strong> implicitly
convert to a user-defined type:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="w"> </span><span class="p">(</span><span class="n">Rational</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">func</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w">   </span><span class="c1">// this works</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">func()</span></code> works because Rational has a conversion
constructor that converts int values to Rational ones.
C++ provides a keyword <code class="docutils literal notranslate"><span class="pre">explicit</span></code> that requires
a cast - it inhibits the implicit conversion of a user defined type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">explicit</span><span class="w"> </span><span class="n">Rational</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>

<span class="k">explicit</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
</pre></div>
</div>
<p>And the previous expressions need casts
or an explicit constructor call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rational</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rational</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w">       </span><span class="c1">// constructor</span>
<span class="n">func</span><span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">              </span><span class="c1">// constructor</span>
<span class="n">func</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Rational</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"> </span><span class="c1">// cast</span>
<span class="n">func</span><span class="p">((</span><span class="n">Rational</span><span class="p">)</span><span class="mi">3</span><span class="p">);</span><span class="w">              </span><span class="c1">// c-style cast</span>

<span class="c1">// explicitly convert a Rational to string</span>
<span class="c1">// using functional conversion syntax</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition-more-to-explore admonition">
<p class="admonition-title">More to Explore</p>
<ul>
<li><p><a class="reference external" href="https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading">Operator overloading in C++</a> from stackoverflow.
Much of the content in this section was taken from there.</p></li>
<li><p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/converting_constructor">Converting constructors</a></p></li>
<li><p>C++ Core Guidelines for <a class="reference external" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#SS-overload">overloading</a></p></li>
<li><p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/operator_comparison">Comparison operators</a> from cppreference.com.</p></li>
<li><p><a class="reference external" href="https://en.cppreference.com/w/cpp/named_req/Compare">Named requirements: Compare</a>.
This page also includes a list of the parts of the STL that expect types
that satisfy this requirement.</p></li>
<li><p>Effective Java, 3rd edition, Joshua Bloch. Addison-Wesley Professional, Jan 2018.</p>
<p>The section regarding overloading toString is in section 12 of the
third edition and section 10 of the second.</p>
</li>
</ul>
</div>
</section>
</section>


  

  <div id="scprogresscontainer">
    You have attempted <span id="scprogresstotal"></span> of <span id="scprogressposs"></span> activities on this page <div id="subchapterprogress" aria-label="Page progress"></div>
  </div>

  <ul role="navigation" class="nextprev-list nextprev-list" aria-label="Change page">
<li id="relations-prev" class="navLink" title='Previous Section - 8.2. Static members' data-toggle="tooltip">
  <a href="static.html" aria-label="Previous - 8.2. Static members">
    <i class='prevNav glyphicon glyphicon-chevron-left'  style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black;"></i>
  </a>
</li>

  <li id="relations-next" class="navLink" title='Next Section - 8.4. Friend vs non-friend functions' data-toggle="tooltip" >
    <a href="friend.html" aria-label="Next - 8.4. Friend vs non-friend functions">
      <i id="relationsNextIcon" class='nextNav glyphicon glyphicon-chevron-right' style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black; "></i>
    </a>
  </li>
</ul>

<script>
window.addEventListener('load', (event) => {
  $('#relations-prev').tooltip({'placement': 'right', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement': 'left', 'delay': { show: 100, hide: 50}});
});
</script>

</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2025 Dave Parillo.
      Created using <a href="http://runestoneinteractive.org/">Runestone</a> 6.6.2.
    </p>
  </div>
</footer>




<script>
  window.addEventListener('load', (event) => {
    runestoneComponents.getSwitch();
  });
</script>


  </body>
</html>