<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Glossary &#8212; CISC 187 Course Reader Overview</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/matrixeq.css?v=58BC228F" />
    <link rel="stylesheet" type="text/css" href="_static/CodeChat.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/handsontable@7.2.2/dist/handsontable.full.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/webgldemo.css?v=B36B48D" />
    <link rel="stylesheet" type="text/css" href="_static/webglinteractive.css?v=910DF1E1" />
    <link rel="stylesheet" type="text/css" href="_static/accessibility.css?v=50109A2C" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-3.4.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/presenter_mode.css?v=9FF1320F" />
    <link rel="stylesheet" type="text/css" href="_static/jquery-ui-1.10.3.custom.min.css?v=97E0178A" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/user-highlights.css?v=A2326E52" />
    <link rel="stylesheet" type="text/css" href="_static/runestone-custom-sphinx-bootstrap.css?v=5.5.5" />
    <link rel="stylesheet" type="text/css" href="_static/theme-overrides.css?v=2DAFE138" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/pytutor-embed.bundle.js?v=268B5C04"></script>
    <script src="_static/matrixeq.js?v=D64CFA5A"></script>
    <script src="_static/animationbase.js?v=A043C3A7"></script>
    <script src="_static/html4css1.css?v=4533ACD3"></script>
    <script src="_static/jquery.highlight.js?v=F1C496C8"></script>
    <script src="_static/sql-wasm.js?v=D71B5933"></script>
    <script src="https://cdn.jsdelivr.net/npm/handsontable@7.2.2/dist/handsontable.full.js"></script>
    <script src="_static/webglinteractive.js?v=2B768384"></script>
    <script src="_static/FileSaver.min.js?v=8408C997"></script>
    <script src="_static/Blob.js?v=AEC2447"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.emitter.bidi.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.emitter.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.fallbacks.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.messagestore.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.parser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.language.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega@4.0.0-rc.2/build/vega.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@2.5.0/build/vega-lite.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@3.14.0/build/vega-embed.js"></script>
    <script src="_static/runestone.js?v=92D8BBF0"></script>
    <script src="_static/jquery-ui-1.10.3.custom.min.js?v=2B07FE4F"></script>
    <script src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
    <script src="_static/jquery-fix.js?v=1226591B"></script>
    <script src="_static/bootstrap-sphinx.js"></script>
    <script src="_static/jquery.idle-timer.js?v=E942DAF1"></script>
    <script src="_static/presenter_mode.js?v=2DF16FB4"></script>
    <script src="_static/theme.js?v=D899FB97"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendix A - Development Environment" href="back-matter/app-a/index.html" />
    <link rel="prev" title="17.4. std::copy and Iterator Adapters" href="algorithms/copy.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<link rel="shortcut icon" href="/cisc187-reader/static/favicon.ico" type="image/ico" />

<script type="text/javascript">
  eBookConfig = {};
  
    eBookConfig.useRunestoneServices = false;
    eBookConfig.host = 'https://daveparillo.github.io/cisc187-reader/' || 'http://127.0.0.1:8000';
    eBookConfig.app = eBookConfig.host+'/cisc187-reader';
    eBookConfig.course = 'cisc187-reader';
    eBookConfig.basecourse = 'cisc187-reader';
    eBookConfig.isLoggedIn = false;
  
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.python3 = true;
  eBookConfig.acDefaultLanguage = 'cpp' ? 'cpp' : 'python'
  eBookConfig.runestone_version = '5.5.5';
  eBookConfig.jobehost = 'https://fierce-ridge-58946.herokuapp.com/http://jobe2.cosc.canterbury.ac.nz';
  eBookConfig.proxyuri_runs = '/jobe/index.php/restapi/runs/';
  eBookConfig.proxyuri_files = '/jobe/index.php/restapi/files/';
  eBookConfig.enable_chatcodes = false ? false : false;


</script>

<!-- Ad Serving Headers Only serve ads to Anonymous Users -->





  </head><body>


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="icon-bar" aria-label="navbar toggle" class="visuallyhidden">toggle navbar</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        
          <a class="brand-logo" style='background: transparent url("_static/img/logo_small.png") no-repeat 0px 0px;'>&nbsp;<span aria-label="logo" class="visuallyhidden">Runestone Logo</span> </a>
        
        <a class="navbar-brand" href="index.html" aria-label="index-page">
          
          cisc187-reader
        </a>
      </div>
    </div>



    <div class="navbar-collapse collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right" >

        <li class="divider-vertical"></li>


        <!-- social media dropdown -->
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>

        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'><span aria-label="Search" class="visuallyhidden">Search</span></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='index.html' aria-label="index-page">Table of Contents</a></li>
            
            <li><a href='genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>
        <!-- <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li> -->

        <!-- <li class="dropdown">             -->
          <li id="scratch_ac_link" class="dropdown"><a href="javascript:ACFactory.toggleScratchActivecode()">
              <i class="glyphicon glyphicon-pencil" style="opacity:0.9;"><span aria-label="Scratch Activecode" class="visuallyhidden">Scratch Activecode</span></i></a></li>
        <!-- </li> -->

        <li class="divider-vertical"></li>

        
      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        
          
          <li class="divider-vertical"></li>
        
        <!-- 
          
  <li id="relations-prev" title="Previous Chapter - <span class="section-number">17.4. </span>std::copy and Iterator Adapters" data-toggle="tooltip">
    <a href="algorithms/copy.html" >
      <i class='glyphicon glyphicon-backward' style='opacity:0.9;'></i>
    </a>
  </li>
  
  <li id="relations-next" title='Next Chapter - Appendix A - Development Environment' data-toggle="tooltip" >              
    <a href="back-matter/app-a/index.html" >
        <i class='glyphicon glyphicon-forward' style='opacity:0.9;'></i>
    </a>
  </li>
  <li class="divider-vertical"></li>

<script type="text/javascript">
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  $('#relations-prev').tooltip(opts);
  $('#relations-next').tooltip(opts);
</script>
        -->
        
          <li></li>
        
      </ul>

      </div> <!-- navbar -->







    </div> <!-- container -->
  </div>
</div>


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content" role="main">
<!-- Ad Serving for Runestone Campaign -->


  
  <div class="section" id="glossary">
<span id="id1"></span><h1>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h1>
<dl class="glossary">
<dt id="term-abstract-base-class">abstract base class</dt><dd><p>A class in which some functions are not implemented.
Abstract bases classes cannot be instantiated — a derived class
must override the abstract virtual function with an implementation.</p>
</dd>
<dt id="term-abstract-data-type">abstract data type</dt><dd><p>Abbreviated <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a>. The realization of a <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a>
as a software component.</p>
</dd>
<dt id="term-abstraction">abstraction</dt><dd><p>A technique used to reduce the complexity of systems and data.
An abstraction often involves a simplified model of the
‘real world’ for the purposes of achieving goals
within a specific problem domain.</p>
<p>Data abstraction enforces a clear separation between the
abstract properties of a <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> and the concrete details
of its implementation.</p>
</dd>
<dt id="term-activation-record">activation record</dt><dd><p>The entity that is stored on the <a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a> during
program execution.
It stores any active <a class="reference internal" href="#term-local-variable"><span class="xref std std-term">local variable</span></a> and the return
address from which a new subroutine is being called, so that
this information can be recovered when the subroutine
terminates.</p>
</dd>
<dt id="term-activecode">activecode</dt><dd><p>A unique interpreter environment that allows code to be executed within a web browser.</p>
</dd>
<dt id="term-address">address</dt><dd><p>A location in memory.</p>
</dd>
<dt id="term-adjacency-list">adjacency list</dt><dd><p>An implementation for a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> that uses an (array-based)
<a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> to represent the <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> of the
graph, and each vertex is in turn represented by a
(linked) list of the vertices that are
<a class="reference internal" href="#term-neighbor"><span class="xref std std-term">neighbors</span></a>.</p>
</dd>
<dt id="term-adjacency-matrix">adjacency matrix</dt><dd><p>An implementation for a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> that uses a 2-dimensional
array where each row and each column corresponds to a
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> in the <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>. A given row and column in
the matrix corresponds to an edge from the <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a>
corresponding to the row to the vertex corresponding to the
column.</p>
</dd>
<dt id="term-adjacent">adjacent</dt><dd><p>Two <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> of a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or two
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> of a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> are said to be
adjacent if they have an <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a> connecting them.
If the edge is directed from <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(b\)</span>,
then we say that <span class="math notranslate nohighlight">\(a\)</span> is adjacent to <span class="math notranslate nohighlight">\(b\)</span>,
and <span class="math notranslate nohighlight">\(b\)</span> is adjacent from <span class="math notranslate nohighlight">\(a\)</span>.</p>
</dd>
<dt id="term-ADT">ADT</dt><dd><p>Abbreviation for <a class="reference internal" href="#term-abstract-data-type"><span class="xref std std-term">abstract data type</span></a>.</p>
</dd>
<dt id="term-adversary-argument">adversary argument</dt><dd><p>A type of <a class="reference internal" href="#term-lower-bounds-proof"><span class="xref std std-term">lower bounds proof</span></a> for a problem where a
(fictional) “adversary” is assumed to control access to an
algorithm’s input, and which yields information about that input
in such a way
that will drive the cost for any proposed algorithm to solve the
problem as high as possible.
So long as the adversary never gives an answer that conflicts
with any previous answer, it is permitted to do whatever
necessary to make the algorithm require as much cost as
possible.</p>
</dd>
<dt id="term-aggregate-type">aggregate type</dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> whose <a class="reference internal" href="#term-member"><span class="xref std std-term">members</span></a> have subparts.
For example, a typical database record.
Another term for this is <a class="reference internal" href="#term-composite-type"><span class="xref std std-term">composite type</span></a>.</p>
</dd>
<dt id="term-algorithm">algorithm</dt><dd><p>A general step by step process for solving a <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.</p>
</dd>
<dt id="term-algorithm-analysis">algorithm analysis</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>growth rate :label: key concept</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>upper bound :label: key concept</p>
</dd>
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>lower bound :label: key concept</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>asymptotic analysis :label: synonym</p>
</dd>
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>asymptotic algorithm analysis :label: formal synonym</p>
</dd>
</dl>
<p>A less formal version of the term
<a class="reference internal" href="#term-asymptotic-algorithm-analysis"><span class="xref std std-term">asymptotic algorithm analysis</span></a>, generally used as a
synonym for <a class="reference internal" href="#term-asymptotic-analysis"><span class="xref std std-term">asymptotic analysis</span></a>.</p>
</dd>
<dt id="term-alphabet-trie">alphabet trie</dt><dd><p>A <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a> data structure for storing variable-length
strings.
Level <span class="math notranslate nohighlight">\(i\)</span> of the tree corresponds to the letter in
position <span class="math notranslate nohighlight">\(i\)</span> of the string.
The root will have potential branches on each intial letter of
string.
Thus, all strings starting with “a” will be stored in the “a”
branch of the tree.
At the second level, such strings will be separated by branching
on the second letter.</p>
</dd>
<dt id="term-ancestor">ancestor</dt><dd><p>In a tree, for a given node <span class="math notranslate nohighlight">\(A\)</span>, any node on a
path from <span class="math notranslate nohighlight">\(A\)</span> up to the root is an ancestor of
<span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt id="term-anti-pattern">anti-pattern</dt><dd><p>A common response to a recurring problem that is generally ineffective.
Anti-patterns represent examples that you <strong>should not</strong> emulate!
As bad as they are, they can still be instructive.
Compare to <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a>.</p>
</dd>
<dt id="term-antisymmetric">antisymmetric</dt><dd><p>In set notation, relation <span class="math notranslate nohighlight">\(R\)</span> is antisymmetric if whenever
<span class="math notranslate nohighlight">\(aRb\)</span> and <span class="math notranslate nohighlight">\(bRa\)</span>, then <span class="math notranslate nohighlight">\(a = b\)</span>, for all
<span class="math notranslate nohighlight">\(a, b \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-api">api</dt><dt id="term-API">API</dt><dd><p>An Application Programming Interface (API) is a set of functions,
or classes used by a program.
Often an API provides a family of functions or classes that work
together to provide a complete set of capabilities.</p>
</dd>
<dt id="term-approximation-algorithm">approximation algorithm</dt><dd><p>An algorthm for an <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problem</span></a> that finds a
good, but not necessarily cheapest, solution.</p>
</dd>
<dt id="term-array-based-list">array-based list</dt><dd><p>An implementation for the <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> ADT that uses an array to
store the list elements.</p>
</dd>
<dt id="term-array-based-queue">array-based queue</dt><dd><p>Analogous to an <a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a>, this uses an array to
store the elements when implementing the <a class="reference internal" href="#term-queue"><span class="xref std std-term">queue</span></a> ADT.</p>
</dd>
<dt id="term-array-based-stack">array-based stack</dt><dd><p>Analogous to an <a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a>, this uses an array to
store the elements when implementing the <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a> ADT.</p>
</dd>
<dt id="term-ASCII-character-coding">ASCII character coding</dt><dd><p>American Standard Code for Information Interchange.
A commonly used method for encoding characters using a binary code.
Standard ASCII uses an 8-bit code to represent upper and lower
case letters, digits, some punctuation, and some number of
non-printing characters (such as carrage return).
Now largely replaced by UTF-8 encoding.</p>
</dd>
<dt id="term-assembly-code">assembly code</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>intermediate code :label: form of</p>
</dd>
</dl>
<p>A form of  <a class="reference internal" href="#term-intermediate-code"><span class="xref std std-term">intermediate code</span></a> created by a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that
is easy to convert into the final form that the computer can
execute.
An assembly language is typically a direct mapping of one or a
few instructions that the CPU can execute into a mnemonic form
that is relatively easy for a human to read.</p>
</dd>
<dt id="term-assignable">assignable</dt><dd><p>A <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> is <em>assignable</em> if the type can be copy-assigned
a new value as the left-hand side of the operation.</p>
<p>References are not assignable because once initialized,
they cannot be assigned a new value.</p>
</dd>
<dt id="term-associative-container">associative container</dt><dd><p>A set of sorted data structures that can be quickly searched.
<code class="docutils literal notranslate"><span class="pre">map</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> are examples.</p>
</dd>
<dt id="term-asymptotic-algorithm-analysis">asymptotic algorithm analysis</dt><dd><p>A more formal term for <a class="reference internal" href="#term-asymptotic-analysis"><span class="xref std std-term">asymptotic analysis</span></a>.</p>
</dd>
<dt id="term-asymptotic-analysis">asymptotic analysis</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>algorithm analysis :label: synonym</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>asymptotic algorithm analysis :label: formal synonym</p>
</dd>
</dl>
<p>A method for estimating the efficiency of an algorithm or
computer program by identifying its <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a>.
Asymptotic analysis also gives a way to
define the inherent difficulty of a <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.
We frequently use the term <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a> to mean
the same thing.</p>
</dd>
<dt id="term-attribute">attribute</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a synonym for <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data member</span></a>.</p>
</dd>
<dt id="term-backing-storage">backing storage</dt><dt id="term-backing-store">backing store</dt><dd><p>The underlying storage for an <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a>.</p>
</dd>
<dt id="term-bag">bag</dt><dd><p>In set notation, a bag is a collection of elements with no order
(like a set), but which allows for duplicate-valued elements
(unlike a set).
A synonym for <a class="reference internal" href="#term-multilist"><span class="xref std std-term">multilist</span></a>.</p>
</dd>
<dt id="term-balanced-tree">balanced tree</dt><dd><p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> where the <a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtrees</span></a> meet some
criteria for being balanced.
Two possibilities are that the tree is
<a class="reference internal" href="#term-height-balanced"><span class="xref std std-term">height balanced</span></a>, or that the tree has a roughly equal
number of <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> in each subtree.</p>
</dd>
<dt id="term-base">base</dt><dd><p>Synonym for <a class="reference internal" href="#term-radix"><span class="xref std std-term">radix</span></a>.</p>
</dd>
<dt id="term-base-case">base case</dt><dd><p>In <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>, the base case is the termination condition.
This is a simple input or value that can be solved
without resorting to a recursive call.</p>
</dd>
<dt id="term-base-class">base class</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a class from which another class <a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherits</span></a>.
The class that inherits is called a <a class="reference internal" href="#term-subclass"><span class="xref std std-term">subclass</span></a> or <a class="reference internal" href="#term-derived-class"><span class="xref std std-term">derived class</span></a>.</p>
</dd>
<dt id="term-base-type">base type</dt><dd><p>The <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> for the elements in a set.
For example, the set might consist of the integer values 3, 5, and 7.
In this example, the base type is integers.</p>
</dd>
<dt id="term-best-case">best case</dt><dd><p>In algorithm analysis, the <a class="reference internal" href="#term-problem-instance"><span class="xref std std-term">problem instance</span></a> from among
all problem instances for a given input size <span class="math notranslate nohighlight">\(n\)</span> that has
least cost. Note that the best case is <strong>not</strong> when <span class="math notranslate nohighlight">\(n\)</span> is
small, since we are referring to the best from a class of inputs
(i.e, we want the best of those inputs of size <span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd>
<dt id="term-big-O-notation">big-O notation</dt><dt id="term-big-Oh-notation">big-Oh notation</dt><dd><p>In algorithm analysis, a shorthand notation for describing the
upper bound for an algorithm or problem.</p>
</dd>
<dt id="term-binary-search">binary search</dt><dd><p>A standard <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursive</span></a> algorithm for finding
the <a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a> with a given <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> within
a sorted list.
It runs in <span class="math notranslate nohighlight">\(O(\log n)\)</span> time.
At each step, look at the middle of the current sublist, and throw
away the half of the records whose keys are either too small or
too large.</p>
</dd>
<dt id="term-binary-tree">binary tree</dt><dd><p>A non-linear data structure with a set of nodes which is either empty,
or else has a root node together two binary trees, called the left and right
<a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtrees</span></a>, which are disjoint from each
other and from the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-binary-trie">binary trie</dt><dd><p>A <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> whose structure is that of a <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>.
Generally this is an implementation for a <a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search tree</span></a>.
This means that the <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> values are thought of a
binary digits, with the digit in the position corresponding to
this a node’s <a class="reference internal" href="#term-level"><span class="xref std std-term">level</span></a> in the tree indicating a left branch
if it is “0”, or a right branch if it is “1”.
Examples include the <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a> and the
<a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>.</p>
</dd>
<dt id="term-binning">binning</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, binning is a type of <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.
Say we are given keys in the range 0 to 999, and have a hash
table of size 10.
In this case, a possible hash function might simply divide the
key value by 100.
Thus, all keys in the range 0 to 99 would hash to slot 0, keys
100 to 199 would hash to slot 1, and so on.
In other words, this hash function “bins” the first 100 keys to
the first slot, the next 100 keys to the second slot, and so
on.
This approach tends to make the hash function dependent on the
distribution of the high-order bits of the keys.</p>
</dd>
<dt id="term-bintree">bintree</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>flyweight :label: uses</p>
</dd>
</dl>
<p>A <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> in the form of binary
<a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>, typically used to store point data in two or more
dimensions.
Similar to a <a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a> except that at each level, it
splits one dimension in half.
Since many leaf nodes of the PR quadtree will contain no data
points, implementation often makes use of the <a class="reference internal" href="#term-flyweight"><span class="xref std std-term">flyweight</span></a>
<a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a>.</p>
</dd>
<dt id="term-block">block</dt><dd><p>Defines a <a class="reference internal" href="#term-scope"><span class="xref std std-term">scope</span></a> within a program.
A synonym for <a class="reference internal" href="#term-code-block"><span class="xref std std-term">code block</span></a>.</p>
</dd>
<dt id="term-boolean-variable">boolean variable</dt><dd><p>A variable that takes on one of the two values <code class="docutils literal notranslate"><span class="pre">true</span></code> and
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</dd>
<dt id="term-bucket">bucket</dt><dd><p>In <a class="reference internal" href="#term-bucket-hashing"><span class="xref std std-term">bucket hashing</span></a>, a bucket is a sequence of
<a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> that are grouped
together.</p>
</dd>
<dt id="term-bucket-hashing">bucket hashing</dt><dd><p>A method of <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a> where multiple <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a>
of the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> are grouped together to form a
<a class="reference internal" href="#term-bucket"><span class="xref std std-term">bucket</span></a>.
The <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> then either hashes to some bucket, or
else it hashes to a <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a> in the normal way, but
this home slot is part of some bucket.
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">Collision resolution</span></a> is handled
first by attempting to find a free position within the same
bucket as the home slot.
If the bucket if full, then the record is placed in an
<a class="reference internal" href="#term-overflow-bucket"><span class="xref std std-term">overflow bucket</span></a>.</p>
</dd>
<dt id="term-bug">bug</dt><dd><p>An error in a program.</p>
</dd>
<dt id="term-call-stack">call stack</dt><dd><p>Known also as execution stack. A stack that stores the function
call sequence and the return address for each function.</p>
</dd>
<dt id="term-cartesian-product">cartesian product</dt><dd><p>For sets, this is another name for the <a class="reference internal" href="#term-set-product"><span class="xref std std-term">set product</span></a>.</p>
</dd>
<dt id="term-ceiling">ceiling</dt><dd><p>Written <span class="math notranslate nohighlight">\(\lceil x \rceil\)</span>, for real value <span class="math notranslate nohighlight">\(x\)</span> the
ceiling is the least integer <span class="math notranslate nohighlight">\(\geq x\)</span>.</p>
</dd>
<dt id="term-child">child</dt><dd><p>In a tree, the set of <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> directly pointed to
by a node <span class="math notranslate nohighlight">\(R\)</span> are the <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd>
<dt id="term-class">class</dt><dd><p>In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>
an ADT and its implementation together make up a class.
An instantiation of a class within a program is termed an
<a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a>.</p>
</dd>
<dt id="term-class-hierarchy">class hierarchy</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a set of classes and their interrelationships.
One of the classes is the <a class="reference internal" href="#term-base-class"><span class="xref std std-term">base class</span></a>, and the others are
<a class="reference internal" href="#term-derived-class"><span class="xref std std-term">derived classes</span></a> that <a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherit</span></a> either
directly or indirectly from the base class.</p>
</dd>
<dt id="term-class-invariant">class invariant</dt><dt id="term-type-invariant">type invariant</dt><dt id="term-invariants">invariants</dt><dd><p>A class invariant is an assertion about conditions which must be true
in order for a class to remain valid.</p>
</dd>
<dt id="term-client">client</dt><dd><p>The user of a service.</p>
</dd>
<dt id="term-closed-hash-system">closed hash system</dt><dd><p>A <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a> where all records are stored in slots of
the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
This is in contrast to an <a class="reference internal" href="#term-open-hash-system"><span class="xref std std-term">open hash system</span></a>.</p>
</dd>
<dt id="term-code-block">code block</dt><dd><p>Defines a <a class="reference internal" href="#term-scope"><span class="xref std std-term">scope</span></a> within a program.
A synonym for <a class="reference internal" href="#term-block"><span class="xref std std-term">block</span></a>.</p>
</dd>
<dt id="term-code-generation">code generation</dt><dd><p>A phase in a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that transforms
<a class="reference internal" href="#term-intermediate-code"><span class="xref std std-term">intermediate code</span></a> into the final executable form of the
code.
More generally, this can refer to the process of turning a parse
tree (that determines the correctness of the structure of the
program) into actual instructions that the computer can execute.</p>
</dd>
<dt id="term-code-optimization">code optimization</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>assembly code :label: changes</p>
</dd>
</dl>
<p>A phase in a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that makes changes in the code
(typically <a class="reference internal" href="#term-assembly-code"><span class="xref std std-term">assembly code</span></a>) with the goal of replacing
it with a version of the code that will run faster while
performing the same computation.</p>
</dd>
<dt id="term-codelens">codelens</dt><dd><p>An interactive environment that allows the user to control the
step by step execution of a program</p>
</dd>
<dt id="term-cohesion">cohesion</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a term that refers to the degree to which a class has a single
well-defined role or responsibility.</p>
</dd>
<dt id="term-collision">collision</dt><dd><p>In a <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a>, this refers to the case where two
search <a class="reference internal" href="#term-key"><span class="xref std std-term">keys</span></a> are mapped by the
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> to the same
slot in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
This can happen on insertion or search when another record has
already been hashed to that slot.
In this case, a <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hash system</span></a> will require a
process known as <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> to find the
location of the desired record.</p>
</dd>
<dt id="term-collision-resolution">collision resolution</dt><dd><p>The outcome of a <a class="reference internal" href="#term-collision-resolution-policy"><span class="xref std std-term">collision resolution policy</span></a>.</p>
</dd>
<dt id="term-collision-resolution-policy">collision resolution policy</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the process of resolving a
<a class="reference internal" href="#term-collision"><span class="xref std std-term">collision</span></a>.
Specifically in a <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hash system</span></a>, this is the
process of finding the proper position in a <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>
that contains the
desired record if the <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> did not return the
correct position for that record due to a <a class="reference internal" href="#term-collision"><span class="xref std std-term">collision</span></a> with
another record.</p>
</dd>
<dt id="term-comment">comment</dt><dd><p>Information in a program that is meant for other programmers (or anyone
reading the source code) and has no effect on the execution of the
program.</p>
</dd>
<dt id="term-comparable">comparable</dt><dd><p>The concept that two objects can be compared to determine if they
are equal or not, or to determine which one is greater than the
other.
In set notation, elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> of a set are
comparable under a given relation <span class="math notranslate nohighlight">\(R\)</span> if either
<span class="math notranslate nohighlight">\(xRy\)</span> or <span class="math notranslate nohighlight">\(yRx\)</span>.
To be reliably compared for a greater/lesser relationship,
the values being compared must belong to a <a class="reference internal" href="#term-total-order"><span class="xref std std-term">total order</span></a>.
In programming, the property of a data type such that two
elements of the type can be compared to determine if they the
same (a weaker version), or which of the two is larger (a
stronger version).</p>
</dd>
<dt id="term-comparator">comparator</dt><dd><p>A function given as a parameter to a method of a library
(or alternatively, a parameter for a C++ template or a Java
generic).
The comparator function concept provides a generic way
encapulates the process of performing a comparison between two
objects of a specific type.
For example, if we want to write a generic sorting routine, that
can handle any record type, we can require that the user of the
sorting routine pass in a comparator function
to define how records in the collection are to be compared.</p>
</dd>
<dt id="term-comparison">comparison</dt><dd><p>The act of comparing two <a class="reference internal" href="#term-key"><span class="xref std std-term">keys</span></a> or
<a class="reference internal" href="#term-record"><span class="xref std std-term">records</span></a>.
For many <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data types</span></a>, a comparison has
constant time cost.
For others, such as <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> the cost often increases
as the number of elements increases.</p>
</dd>
<dt id="term-compile">compile</dt><dd><p>To translate a program written in a high-level language into a
low-level language all at once, in preparation for later execution.</p>
</dd>
<dt id="term-compile-time-error">compile-time error</dt><dd><p>Errors detected by the compiler.
Compare to <a class="reference internal" href="#term-runtime-error"><span class="xref std std-term">runtime error</span></a>, <a class="reference internal" href="#term-link-error"><span class="xref std std-term">link error</span></a>,
and <a class="reference internal" href="#term-semantic-error"><span class="xref std std-term">semantic error</span></a>.</p>
</dd>
<dt id="term-compile-time-polymorphism">compile-time polymorphism</dt><dt id="term-Compile-time-polymorphism">Compile-time polymorphism</dt><dd><p>A form of <a class="reference internal" href="#term-polymorphism"><span class="xref std std-term">polymorphism</span></a> known as Overloading.
Overloaded methods have the same names, but different signatures
as a method available elsewhere in the class.
Compare to <a class="reference internal" href="#term-runtime-polymorphism"><span class="xref std std-term">runtime polymorphism</span></a>.</p>
</dd>
<dt id="term-compiler">compiler</dt><dd><p>A computer program that reads computer programs and converts
them into a form that can be directly excecuted by some form of
computer.
The major phases in a compiler include <a class="reference internal" href="#term-lexical-analysis"><span class="xref std std-term">lexical analysis</span></a>,
<a class="reference internal" href="#term-syntax-analysis"><span class="xref std std-term">syntax analysis</span></a>, <a class="reference internal" href="#term-intermediate-code-generation"><span class="xref std std-term">intermediate code generation</span></a>,
<a class="reference internal" href="#term-code-optimization"><span class="xref std std-term">code optimization</span></a>, and <a class="reference internal" href="#term-code-generation"><span class="xref std std-term">code generation</span></a>.
More broadly, a compiler can be viewed as <a class="reference internal" href="#term-parser"><span class="xref std std-term">parsing</span></a> the program to verify that it is syntactically
correct, and then doing <a class="reference internal" href="#term-code-generation"><span class="xref std std-term">code generation</span></a> to convert the
hig-level program into something that the computer can execute.</p>
</dd>
<dt id="term-complete-binary-tree">complete binary tree</dt><dd><p>A binary tree where the nodes are filled in row by row, with the
bottom row filled in left to right.
Due to this requirement, there is only one tree of <span class="math notranslate nohighlight">\(n\)</span>
nodes for any value of <span class="math notranslate nohighlight">\(n\)</span>.
Since storing the records in an array in row order leads to a
simple mapping from a node’s position in the array to its
<a class="reference internal" href="#term-parent"><span class="xref std std-term">parent</span></a>, <a class="reference internal" href="#term-sibling"><span class="xref std std-term">siblings</span></a>, and
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>, the array representation is most
commonly used to implement the complete binary tree.
The <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> data structure is a complete binary tree with
partial ordering constraints on the node values.</p>
</dd>
<dt id="term-Composite-design-pattern">Composite design pattern</dt><dd><p>Given a class hierarchy representing a set of objects, and a
container for a collection of objects, the composite
<a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> addresses the relationship between the
object hierarchy and a bunch of behaviors on the objects.
In the composite design, each object is required to implement
the collection of behaviors.
This is in contrast to the procedural approach where a behavior
(such as a tree <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a>) is implemented as a
method on  the object collection (such as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>).
Procedural tree traversal requires that the tree have a method
that understands what to do when it encounters any of the object
types (<a class="reference internal" href="#term-internal-node"><span class="xref std std-term">internal</span></a> or
<a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf nodes</span></a>) that the tree might contain.
The composite approach would have the tree call the “traversal”
method on its root node, which then knows how to perform the
“traversal” behavior.
This might in turn require invoking the traversal method of
other objects (in this case, the children of the root).</p>
</dd>
<dt id="term-composite-type">composite type</dt><dd><p>A type whose <a class="reference internal" href="#term-member"><span class="xref std std-term">members</span></a> have subparts.
For example, a typical database record.
Another term for this is <a class="reference internal" href="#term-aggregate-type"><span class="xref std std-term">aggregate type</span></a>.</p>
</dd>
<dt id="term-composition">composition</dt><dd><p>Relationships between classes based on usage rather than
<a class="reference internal" href="#term-inherit"><span class="xref std std-term">inheritance</span></a>, i.e. a <strong>HAS-A</strong> relationship.
For example, some code in class ‘A’ has a reference to some
other class ‘B’.</p>
</dd>
<dt id="term-compound-type">compound type</dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> built up from simpler parts.
Compare to <a class="reference internal" href="#term-simple-type"><span class="xref std std-term">simple type</span></a> and <a class="reference internal" href="#term-composite-type"><span class="xref std std-term">composite type</span></a>.</p>
</dd>
<dt id="term-constant-running-time">constant running time</dt><dt id="term-constant-time">constant time</dt><dd><p>The cost of a function whose running time is not related to its
input size.
In Theta notation, this is traditionally written as
<span class="math notranslate nohighlight">\(\Theta(1)\)</span>.</p>
</dd>
<dt id="term-container">container</dt><dt id="term-container-class">container class</dt><dd><p>A <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> that stores a collection of
<a class="reference internal" href="#term-record"><span class="xref std std-term">records</span></a>.
Typical examples are arrays and
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash tables</span></a>.</p>
</dd>
<dt id="term-cost">cost</dt><dd><p>The amount of resources that the solution consumes.</p>
</dd>
<dt id="term-cost-model">cost model</dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a definition for the cost of each
basic operation performed by the algorithm,
along with a definition for the size of the input.
Having these definitions allows us to calculate the <a class="reference internal" href="#term-cost"><span class="xref std std-term">cost</span></a>
to run the algorithm on a given input, and from there determine
the <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> of the algorithm.
A cost model would be considered “good” if it yields predictions
that conform to our understanding of reality.</p>
</dd>
<dt id="term-CPU">CPU</dt><dd><p>Acronym for Central Processing Unit, the primary processing
device for a computer.</p>
</dd>
<dt id="term-current-position">current position</dt><dd><p>A property of some list ADTs, where there is maintained a
“current position” state that can be referred to later.</p>
</dd>
<dt id="term-data-field">data field</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a synonym for <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data member</span></a>.</p>
</dd>
<dt id="term-data-item">data item</dt><dd><p>A piece of information or a record whose value is drawn from a type.</p>
</dd>
<dt id="term-data-member">data member</dt><dd><p>The variables that together define the space required by a data
item are referred to as data members.
Some of the commonly used synonyms include <a class="reference internal" href="#term-data-field"><span class="xref std std-term">data field</span></a>,
<a class="reference internal" href="#term-attribute"><span class="xref std std-term">attribute</span></a>, and <a class="reference internal" href="#term-instance-variable"><span class="xref std std-term">instance variable</span></a>.</p>
</dd>
<dt id="term-data-structure">data structure</dt><dd><p>The implementation for an <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a>.</p>
</dd>
<dt id="term-data-type">data type</dt><dd><p>A type together with a collection of operations to manipulate
the type.</p>
</dd>
<dt id="term-debugging">debugging</dt><dd><p>The process of finding and removing any of the three kinds of
programming errors.</p>
</dd>
<dt id="term-decision-tree">decision tree</dt><dd><p>A theoretical construct for modeling the behavior of algorithms.
Each point at which the algorithm makes a decision (such as an
if statement) is modeled by a branch in the tree that represents
the algorithms behavior.
Decision trees can be used in
<a class="reference internal" href="#term-lower-bounds-proof"><span class="xref std std-term">lower bounds proofs</span></a>,
such as the proof that sorting requires
<span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span> comparisons in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>.</p>
</dd>
<dt id="term-declaration">declaration</dt><dd><p>A declaration introduces a new <a class="reference internal" href="#term-name"><span class="xref std std-term">name</span></a>
and <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> into a <a class="reference internal" href="#term-scope"><span class="xref std std-term">scope</span></a>.</p>
</dd>
<dt id="term-depth">depth</dt><dd><p>The depth of a node <span class="math notranslate nohighlight">\(M\)</span> in a tree is the length
of the path from the root of the tree to <span class="math notranslate nohighlight">\(M\)</span>.</p>
</dd>
<dt id="term-depth-first-search">depth-first search</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>DFS :label: abbreviation</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>depth-first search tree :label: generates</p>
</dd>
</dl>
<p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> algorithm.
Whenever a <span class="math notranslate nohighlight">\(v\)</span> is <a class="reference internal" href="#term-visit"><span class="xref std std-term">visited</span></a> during the
traversal, DFS will <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> visit all of
<span class="math notranslate nohighlight">\(v\)</span> ‘s <a class="reference internal" href="#term-unvisited"><span class="xref std std-term">unvisited</span></a> <a class="reference internal" href="#term-neighbor"><span class="xref std std-term">neighbors</span></a>.</p>
</dd>
<dt id="term-depth-first-search-tree">depth-first search tree</dt><dd><p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> that can be defined by the operation of a
<a class="reference internal" href="#term-depth-first-search"><span class="xref std std-term">depth-first search</span></a> (DFS) on a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.
This tree would consist of the <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> of the graph
and a subset of the <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> of the graph that was
followed during the DFS.</p>
</dd>
<dt id="term-dequeue">dequeue</dt><dd><p>A specialized term used to indicate removing an element from a queue.</p>
</dd>
<dt id="term-derivation">derivation</dt><dd><p>In formal languages, the process of executing a series of
<a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rules</span></a> from a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a>.
A typical example of a derivation would be the series of
productions executed to go from the <a class="reference internal" href="#term-start-symbol"><span class="xref std std-term">start symbol</span></a> to a
given string.</p>
</dd>
<dt id="term-derived-class">derived class</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
any class within a <a class="reference internal" href="#term-class-hierarchy"><span class="xref std std-term">class hierarchy</span></a> that
<a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherits</span></a> from some other class.
A synonym for <a class="reference internal" href="#term-derived-class"><span class="xref std std-term">derived class</span></a>.</p>
</dd>
<dt id="term-descendant">descendant</dt><dd><p>In a tree, the set of all nodes that have a node <span class="math notranslate nohighlight">\(A\)</span> as an
<a class="reference internal" href="#term-ancestor"><span class="xref std std-term">ancestor</span></a> are the descendants of <span class="math notranslate nohighlight">\(A\)</span>.
In other words, all of the nodes that can be reached from
<span class="math notranslate nohighlight">\(A\)</span> by progressing downwards in tree.
Another way to say it is: The
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> of <span class="math notranslate nohighlight">\(A\)</span>, their children, and so
on.</p>
</dd>
<dt id="term-deserialization">deserialization</dt><dd><p>The process of returning a <a class="reference internal" href="#term-serialization"><span class="xref std std-term">serialized</span></a>
representation for a data structure back to its original
in-memory form.</p>
</dd>
<dt id="term-design-pattern">design pattern</dt><dd><p>An abstraction for describing the design of programs,
that is, the interactions of objects and classes.
Experienced software designers learn and reuse patterns
for combining software components, and design patterns allow
this design knowledge to be passed on to new programmers more quickly.
Examples are <a class="reference internal" href="#term-Composite-design-pattern"><span class="xref std std-term">Composite design pattern</span></a>,
<a class="reference internal" href="#term-flyweight"><span class="xref std std-term">flyweight</span></a>,
<a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>,
<a class="reference internal" href="#term-strategy"><span class="xref std std-term">strategy</span></a>, and
<a class="reference internal" href="#term-visitor"><span class="xref std std-term">visitor</span></a>.</p>
</dd>
<dt id="term-dictionary">dictionary</dt><dd><p>An abstract data type or interface for a data structure or
software subsystem that supports insertion, search, and deletion
of records.</p>
</dd>
<dt id="term-discriminator">discriminator</dt><dd><p>A part of a <a class="reference internal" href="#term-multi-dimensional-search-key"><span class="xref std std-term">multi-dimensional search key</span></a>.
Certain tree data structures such as the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a> and the
<a class="reference internal" href="#term-kd-tree"><span class="xref std std-term">kd tree</span></a> operate by making branching decisions at nodes
of the tree based on a single attribute of the multi-dimensional
key, with the attribute determined by the level of the node in
the tree.</p>
<p>For example, in 2 dimensions, nodes at the odd levels in the
tree might branch based on the <span class="math notranslate nohighlight">\(x\)</span> value of a coordinate,
while at the even levels the tree would branch based on the
<span class="math notranslate nohighlight">\(y\)</span> value of the coordinate.
Thus, the <span class="math notranslate nohighlight">\(x\)</span> coordinate is the discriminator for the odd
levels, while the <span class="math notranslate nohighlight">\(y\)</span> coordinate is the discriminator for
the even levels.</p>
</dd>
<dt id="term-disjoint">disjoint</dt><dd><p>Two parts of a <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> or two
collections with no objects in common are disjoint.
This term is often used in conjunction with a data structure
that has <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> (such as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>).
Also used in the context of <a class="reference internal" href="#term-set"><span class="xref std std-term">sets</span></a>, where two
<a class="reference internal" href="#term-subset"><span class="xref std std-term">subsets</span></a> are disjoint if they share no elements.</p>
</dd>
<dt id="term-disjoint-sets">disjoint sets</dt><dd><p>A collection of <a class="reference internal" href="#term-set"><span class="xref std std-term">sets</span></a>, any pair of which share no
elements in common.
A collection of disjoint sets partitions some objects
such that every object is in exactly one of the disjoint sets.</p>
</dd>
<dt id="term-domain">domain</dt><dd><p>The set of possible inputs to a function.</p>
</dd>
<dt id="term-double-hashing">double hashing</dt><dd><p>A <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method. A second hash
function is used to generate a value <span class="math notranslate nohighlight">\(c\)</span> on the key.
That value is then used by this key as the step size in
<a class="reference internal" href="#term-linear-probing-by-steps"><span class="xref std std-term">linear probing by steps</span></a>.
Since different keys use different step sizes (as generated by
the second hash function), this process avoids the clustering
caused by standard linear probing by steps.</p>
</dd>
<dt id="term-doubly-linked-list">doubly linked list</dt><dd><p>A <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> implementation variant where each list
node contains access pointers to both the previous element and
the next element on the list.</p>
</dd>
<dt id="term-dynamic-array">dynamic array</dt><dd><p>Arrays, once allocated, are of fixed size. A dynamic array puts
an interface around the array so as to appear to allow the array
to grow and shrink in size as necessary. Typically this is done
by allocating a new copy, copying the contents of the old array,
and then returning the old array to <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.
In some programming languages, the term
<a class="reference internal" href="#term-vector"><span class="xref std std-term">vector</span></a> is used as a synonym for dynamic array.</p>
</dd>
<dt id="term-dynamic-memory-allocation">dynamic memory allocation</dt><dd><p>A programming technique where linked objects in a data structure
are created from <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a> as needed. When no longer
needed, the object is either returned to <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a> or
left as <a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a>, depending on the programming language.</p>
</dd>
<dt id="term-edge">edge</dt><dd><p>The connection that links two <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> in a
<a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a>, or <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.</p>
</dd>
<dt id="term-element">element</dt><dd><p>One value or member in a set.</p>
</dd>
<dt id="term-empty">empty</dt><dd><p>For a <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> class, the state of containing no
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>.</p>
</dd>
<dt id="term-encapsulation">encapsulation</dt><dd><p>In programming, the concept of hiding implementation details
from the user of an ADT, and protecting
<a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a> of an
object from outside access.</p>
</dd>
<dt id="term-enqueue">enqueue</dt><dd><p>A specialized term used to indicate inserting an element onto a queue.</p>
</dd>
<dt id="term-enumeration">enumeration</dt><dd><p>The process by which a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> lists every object in
the <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> exactly once.
Thus, a traversal that prints the <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> is said
to enumerate the nodes.
An enumeration can also refer to the actual listing that is
produced by the traversal
(as well as the process that created that listing).</p>
</dd>
<dt id="term-equivalence-class">equivalence class</dt><dd><p>An <a class="reference internal" href="#term-equivalence-relation"><span class="xref std std-term">equivalence relation</span></a> can be used to partition a set
into equivalence classes.</p>
</dd>
<dt id="term-equivalence-relation">equivalence relation</dt><dd><p>Relation <span class="math notranslate nohighlight">\(R\)</span> is an equivalence relation on set
<span class="math notranslate nohighlight">\(\mathbf{S}\)</span> if it is <a class="reference internal" href="#term-reflexive"><span class="xref std std-term">reflexive</span></a>,
<a class="reference internal" href="#term-symmetric"><span class="xref std std-term">symmetric</span></a>, and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.</p>
</dd>
<dt id="term-exception">exception</dt><dd><p>Another name for a runtime error.</p>
</dd>
<dt id="term-exchange">exchange</dt><dd><p>A swap of adjacent records in an array.</p>
</dd>
<dt id="term-executable">executable</dt><dd><p>Another name for object code that is ready to be executed.</p>
</dd>
<dt id="term-exponential-growth-rate">exponential growth rate</dt><dd><p>A <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> function where <span class="math notranslate nohighlight">\(n\)</span> (the input size)
appears in the exponent. For example, <span class="math notranslate nohighlight">\(2^n\)</span>.</p>
</dd>
<dt id="term-external-fragmentation">external fragmentation</dt><dd><p>A condition that arises when a series of memory requests
result in lots of small <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free blocks</span></a>, no one
of which is useful for servicing typical requests.</p>
</dd>
<dt id="term-external-sort">external sort</dt><dd><p>A sorting algorithm that is applied to data stored outside
the program, such as a disk file.
This is in contrast to an <a class="reference internal" href="#term-internal-sort"><span class="xref std std-term">internal sort</span></a> that is meant to
work on data stored in memory.</p>
</dd>
<dt id="term-FIFO">FIFO</dt><dd><p>Abbreviation for “first-in, first-out”.
This is the access paradigm for a <a class="reference internal" href="#term-queue"><span class="xref std std-term">queue</span></a>,
and an old terminolgy for the queue is “FIFO list”.</p>
</dd>
<dt id="term-fixed-length-coding">fixed-length coding</dt><dd><p>Given a collection of objects, a fixed-length coding scheme
assigns a code to each object in the collection using codes that
are all of the same length.
Standard ASCII and Unicode representations for characters are
both examples of fixed-length coding schemes.
This is in contrast to <a class="reference internal" href="#term-variable-length-coding"><span class="xref std std-term">variable-length coding</span></a>.</p>
</dd>
<dt id="term-floor">floor</dt><dd><p>Written <span class="math notranslate nohighlight">\(\lfloor x \rfloor\)</span>, for real value <span class="math notranslate nohighlight">\(x\)</span> the
floor is the greatest integer <span class="math notranslate nohighlight">\(\leq x\)</span>.</p>
</dd>
<dt id="term-flyweight">flyweight</dt><dd><p>A <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> that is meant to solve the following
problem:
You have an application with many objects.
Some of these objects are identical in the information that
they contain, and the role that they play.
But they must be reached from various places, and conceptually they
really are distinct objects.
Because there is so much duplication of the same information,
we want to reduce memory cost by sharing that space.
For example, in document layout,
the letter “C” might be represented by an object that
describes that character’s strokes and bounding box.
However, we do not want to create a separate “C” object everywhere
in the document that a “C” appears.
The solution is to allocate a single copy of the shared representation
for “C” objects.
Then, every place in the document that needs a “C” in a given font,
size, and typeface will reference this single copy.
The various instances of references to a specific form of “C” are
called flyweights.</p>
</dd>
<dt id="term-folding-method">folding method</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, an approach to implementing a
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.
Most typically used when the key is a string, the folding method
breaks the string into pieces (perhaps each letter is a piece,
or a small series of letters is a piece), converts the letter(s)
to an integer value (typically by using its underlying encoding
value), and summing up the pieces.</p>
</dd>
<dt id="term-free-block">free block</dt><dd><p>A block of unused space in a memory pool.</p>
</dd>
<dt id="term-free-block-list">free block list</dt><dd><p>In a memory manager, the list that stores the necessary
information about the current <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free blocks</span></a>.
Generally, this is done with some sort of <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a>,
where each node of the linked list indicates the start position
and length of the free block in the memory pool.</p>
</dd>
<dt id="term-free-store">free store</dt><dd><p>Space available to a program during runtime to be used for
<a class="reference internal" href="#term-dynamic-memory-allocation"><span class="xref std std-term">dynamic memory allocation</span></a> of objects.
The free store is distinct from the <a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a>.
The free store is sometimes referred to as the <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a>,
which can be confusing because <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> more often refers to
a specific data structure. Most programming languages provide
functions to allocate (and maybe to deallocate) objects from the
free store, such as <code class="docutils literal notranslate"><span class="pre">new</span></code> in C++ and Java.</p>
</dd>
<dt id="term-full-tree">full tree</dt><dd><p>A <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> is full if every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> is either a
<a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf node</span></a> or else it is an <a class="reference internal" href="#term-internal-node"><span class="xref std std-term">internal node</span></a> with
two non-empty <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-function">function</dt><dd><p>In programming, a subroutine that takes input parameters and
uses them to compute and return a value.
In this case, it is usually considered bad practice for a
function to change any global variables
(doing so is called a side effect).</p>
</dd>
<dt id="term-fundamental-type">fundamental type</dt><dd><p>One of the <a class="reference internal" href="#term-simple-type"><span class="xref std std-term">simple types</span></a>
provided by the language.
Examples are <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, and <code class="docutils literal notranslate"><span class="pre">double</span></code>.
Types provided by the STL, such as <code class="docutils literal notranslate"><span class="pre">std::string</span></code> and <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>
are not considered ‘fundamental’ types.</p>
</dd>
<dt id="term-garbage">garbage</dt><dd><p>In memory management, any memory that was previously (dynamically)
allocated by the program during runtime, but which is no longer
accessible since all pointers to the memory have been deleted or
overwritten.
In some languages, garbage can be recovered by
<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>.
In languages such as C and C++ that do not provide built-in garbage
collection, so creating garbage is considered a
<a class="reference internal" href="#term-memory-leak"><span class="xref std std-term">memory leak</span></a>.</p>
</dd>
<dt id="term-garbage-collection">garbage collection</dt><dd><p>Languages with garbage collection such
Java, JavaScript, Lisp, and Scheme will periodically reclaim
<a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a> and return it to <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.</p>
</dd>
<dt id="term-general-tree">general tree</dt><dd><p>A tree in which any given node can have any number of
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
This is in contrast to, for example, a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> where
each node has a fixed number of children (some of which might be
<code class="docutils literal notranslate"><span class="pre">null</span></code>).
General tree nodes tend to be harder to implement for this reason.</p>
</dd>
<dt id="term-generic-programming">generic programming</dt><dd><p>A computer programming style in which functions are written
using <em>placeholders for</em> types. In C++ this is accomplished
using :term:templates&lt;template&gt;`.
Templates are used to create actual functions for specific types
as needed.</p>
</dd>
<dt id="term-grammar">grammar</dt><dd><p>A formal definition for what strings make up a <a class="reference internal" href="#term-language"><span class="xref std std-term">language</span></a>,
in terms of a set of <a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rules</span></a>.</p>
</dd>
<dt id="term-graph">graph</dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> <span class="math notranslate nohighlight">\(\mathbf{G} = (\mathbf{V}, \mathbf{E})\)</span>
consists of a set of <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a>
<span class="math notranslate nohighlight">\(\mathbf{V}\)</span> and a set of <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>
<span class="math notranslate nohighlight">\(\mathbf{E}\)</span>, such that each edge in <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> is
a connection between a pair of vertices in <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>.</p>
</dd>
<dt id="term-greedy-algorithm">greedy algorithm</dt><dd><p>An algorithm that makes locally optimal choices at each step.</p>
</dd>
<dt id="term-growth-rate">growth rate</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>lower bound :label: type</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>upper bound :label: type</p>
</dd>
</dl>
<p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, the rate at which the cost
of the <a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> grows as the size of its input grows.</p>
</dd>
<dt id="term-hash-function">hash function</dt><dd><p>In a <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a>, the function that converts a
<a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value to a position in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
The hope is that this position in the hash table contains the
record that matches the key value.</p>
</dd>
<dt id="term-hash-system">hash system</dt><dd><p>The implementation for search based on hash lookup in a
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
The <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> is processed by a
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>, which returns a position in a
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>, which hopefully is the correct position in
which to find the record corresponding to the search key.</p>
</dd>
<dt id="term-hash-table">hash table</dt><dd><p>The data structure (usually an array) that stores data
records for lookup using <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>.</p>
</dd>
<dt id="term-hashing">hashing</dt><dd><p>A search method that uses a <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> to convert a
<a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> into a position within a
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
In a properly implemented <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a>, that position in
the table will have high probability of containing the record
that matches the key value.
Sometimes, the hash function will return an position that does
not store the desired key, due to a process called
<a class="reference internal" href="#term-collision"><span class="xref std std-term">collision</span></a>.
In that case, the desired record is found through a process
known as <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>.</p>
</dd>
<dt id="term-head">head</dt><dd><p>The beginning of a <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a>.</p>
</dd>
<dt id="term-header-guard">header guard</dt><dd><p>In C and C++, used to prevent definitions copied into a file
using the <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive from beging defined
more than once.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef FOO_H_INCLUDED </span><span class="c1">// any name uniquely mapped to file name</span>
<span class="cp">#define FOO_H_INCLUDED</span>
<span class="c1">// contents of the file are here</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</dd>
<dt id="term-header-node">header node</dt><dd><p>Commonly used in implementations for a <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> or
related structure, this <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> preceeds the first element
of the list.
Its purpose is to simplify the code implementation by
reducing the number of special cases that must be programmed
for.</p>
</dd>
<dt id="term-heap">heap</dt><dd><p>This term has two different meanings.
Sometimes, it is a synonym for <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.
A heap may also refer to a particular data structure.
This data structure is a <a class="reference internal" href="#term-complete-binary-tree"><span class="xref std std-term">complete binary tree</span></a> with the
requirement that every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> has a value greater than its
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> (called a <a class="reference internal" href="#term-max-heap"><span class="xref std std-term">max heap</span></a>), or else
the requirement that every node has a value less than its
children (called a <a class="reference internal" href="#term-min-heap"><span class="xref std std-term">min heap</span></a>).
Since it is a complete binary tree, a heap is nearly always
implemented using an array rather than an explicit tree
structure.
To add a new value to a heap, or to remove the extreme value
(the max value in a max-heap or min value in a min-heap) and
update the heap,
takes <span class="math notranslate nohighlight">\(\Theta(\log n)\)</span> time in the worst case.
However, if given all of the values in an unordered array,
the values can be re-arranged to form a heap in only
<span class="math notranslate nohighlight">\(\Theta(n)\)</span> time.
Due to its space and time efficiency, the heap is a
popular choice for implementing a <a class="reference internal" href="#term-priority-queue"><span class="xref std std-term">priority queue</span></a>.</p>
</dd>
<dt id="term-height">height</dt><dd><p>The height of a tree is one more than the <a class="reference internal" href="#term-depth"><span class="xref std std-term">depth</span></a> of the
deepest <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> in the tree.</p>
</dd>
<dt id="term-height-balanced">height balanced</dt><dd><p>The condition the <a class="reference internal" href="#term-depth"><span class="xref std std-term">depths</span></a> of each <a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtree</span></a>
in a tree are roughly the same.</p>
</dd>
<dt id="term-heuristic">heuristic</dt><dd><p>A way to solve a problem that is not guarenteed to be optimal.
While it might not be guarenteed to be optimal, it is generally
expected (by the agent employing the heuristic) to provide a
reasonably efficient solution.</p>
</dd>
<dt id="term-heuristic-algorithm">heuristic algorithm</dt><dd><p>A type of <a class="reference internal" href="#term-approximation-algorithm"><span class="xref std std-term">approximation algorithm</span></a>, that uses a
<a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> to find a good, but not necessarily cheapest,
solution to an <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problem</span></a>.</p>
</dd>
<dt id="term-high-level-language">high-level language</dt><dd><p>A programming language that is designed to be easy for
humans to read and write.</p>
</dd>
<dt id="term-home-position">home position</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a synonym for <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a>.</p>
</dd>
<dt id="term-home-slot">home slot</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is the <a class="reference internal" href="#term-slot"><span class="xref std std-term">slot</span></a> in the
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> determined for a given key by the
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.</p>
</dd>
<dt id="term-Huffman-codes">Huffman codes</dt><dd><p>The codes given to a collection of letters (or other symbols)
through the process of Huffman coding.
Huffman coding uses a <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a> to generate
the codes.
The codes can be of variable length, such that the letters which
are expected to appear most frequently are shorter.
Huffman coding is optimal whenever the true frequencies are
known, and the frequency of a letter is independent of the
context of that letter in the message.</p>
</dd>
<dt id="term-Huffman-coding-tree">Huffman coding tree</dt><dd><p>A Huffman coding tree is a <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full binary tree</span></a>
that is used to represent letters (or other symbols)
efficiently.
Each letter is associated with a node in the tree, and is then
given a <a class="reference internal" href="#term-Huffman-codes"><span class="xref std std-term">Huffman code</span></a> based on the
position of the associated node.
A Huffman coding tree is an example of a binary <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>.</p>
</dd>
<dt id="term-Huffman-tree">Huffman tree</dt><dd><p>Shorter form of the term <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a>.</p>
</dd>
<dt id="term-identifier">identifier</dt><dd><p>An identifier is used to name a type introduced into a program by a <a class="reference internal" href="#term-declaration"><span class="xref std std-term">declaration</span></a>.</p>
<p>An identifier is an arbitrarily long sequence of digits, underscores,
lowercase and uppercase Latin letters.
A valid identifier must begin with a non-digit character (Latin letter, underscore,
Identifiers are case-sensitive (lowercase and uppercase letters are distinct),
and every character is significant.</p>
</dd>
<dt id="term-image-space-decomposition">image-space decomposition</dt><dd><p>A from of <a class="reference internal" href="#term-key-space-decomposition"><span class="xref std std-term">key-space decomposition</span></a> where the
<a class="reference internal" href="#term-key-space"><span class="xref std std-term">key space</span></a> splitting points is predetermined (typically
by splitting in half).
For example, a <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a> splits the letters
being coded into those with codes that start with 0 on the left
side, and those with codes that start with 1 on the right side.
This regular decomposition of the key space is the basis for a
<a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a> data structure.
An image-space decomposition is in opposition to an
<a class="reference internal" href="#term-object-space-decomposition"><span class="xref std std-term">object-space decomposition</span></a>.</p>
</dd>
<dt id="term-indexing">indexing</dt><dd><p>The process of associating a <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> with the
location of a corresponding data record.
The two defining points to the concept of an index is the
association of a key with a record, and the fact that the index
does not actually store the record itself but rather it stores a
<a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to the record.</p>
<p>In this way, a collection of records can be supported by
multiple indices, typically a separate index for each key field
in the record.</p>
</dd>
<dt id="term-induction-step">induction step</dt><dd><p>Part of a <a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">proof by induction</span></a>.
In its simplest form, this is a proof of the implication that if
the theorem holds for $n-1$, then it holds for $n$.
As an alternative, see <a class="reference internal" href="#term-strong-induction"><span class="xref std std-term">strong induction</span></a>.</p>
</dd>
<dt id="term-inherit">inherit</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
the process by which a <a class="reference internal" href="#term-subclass"><span class="xref std std-term">subclass</span></a> gains
<a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a> and <a class="reference internal" href="#term-method"><span class="xref std std-term">methods</span></a>
from a <a class="reference internal" href="#term-base-class"><span class="xref std std-term">base class</span></a>.</p>
</dd>
<dt id="term-inorder-traversal">inorder traversal</dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> that first
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> <a class="reference internal" href="#term-visit"><span class="xref std std-term">visits</span></a> the left
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a>, then visits the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>,
an then recursively visits the right child.</p>
</dd>
<dt id="term-instance-variable">instance variable</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a synonym for <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data member</span></a>.</p>
</dd>
<dt id="term-integrated-development-environment">integrated development environment</dt><dd><p>A software suite that consolidates many tools developers need to
write and test software.
An IDE normally consists of a source code editor, version control,
build automation tools, and a debugger.
Most also automatically complete partially typed keywords and
create commonly used code from templates.</p>
</dd>
<dt id="term-interface">interface</dt><dd><p>An interface is a class-like structure that only contains method
signatures and fields. An interface does not contain an implementation
of the methods or any <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a>.</p>
</dd>
<dt id="term-intermediate-code">intermediate code</dt><dd><p>A step in a typical <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> is to transform the
original high-level language into a form on which it is easier
to do other stages of the process.
For example, some compilers will transform the original
high-level source code into <a class="reference internal" href="#term-assembly-code"><span class="xref std std-term">assembly code</span></a> on which it
can do <a class="reference internal" href="#term-code-optimization"><span class="xref std std-term">code optimization</span></a>, before translating it into its final
executable form.</p>
</dd>
<dt id="term-intermediate-code-generation">intermediate code generation</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>Parse tree :label: walks through</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>intermediate code :label: produces</p>
</dd>
</dl>
<p>A phase in a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a>, that walks through a
<a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a> to produce simple <a class="reference internal" href="#term-assembly-code"><span class="xref std std-term">assembly code</span></a>.</p>
</dd>
<dt id="term-internal-fragmentation">internal fragmentation</dt><dd><p>A condition that occurs when more than <span class="math notranslate nohighlight">\(N\)</span> bytes
are allocated to service a memory request for <span class="math notranslate nohighlight">\(N\)</span>
bytes, wasting free storage.
This is often done to simplify memory management.</p>
</dd>
<dt id="term-internal-node">internal node</dt><dd><p>In a tree, any node that has at least one non-empty
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a> is an  internal node.</p>
</dd>
<dt id="term-internal-sort">internal sort</dt><dd><p>A sorting algorithm that is applied to data stored in memory.
This is in contrast to an <a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external sort</span></a> that is meant to
work on data stored on disk.</p>
</dd>
<dt id="term-interpreter">interpreter</dt><dd><p>In contrast to a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that translates a high-level
program into something that can be repeatedly executed to
perform a computation, an interpreter directly performs
computation on the high-level langauge.</p>
<p>This tends to make the computation much slower than if it were
performed on the directly executable version produced by a
compiler.</p>
</dd>
<dt id="term-irreflexive">irreflexive</dt><dd><p>In set notation, binary relation <span class="math notranslate nohighlight">\(R\)</span> on set <span class="math notranslate nohighlight">\(S\)</span> is
irreflexive if <span class="math notranslate nohighlight">\(aRa\)</span> is never in the relation for
any <span class="math notranslate nohighlight">\(a \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-iterable">iterable</dt><dd><p>A <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> in which each element
can be visited using an <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>.</p>
</dd>
<dt id="term-iterator">iterator</dt><dd><p>In a <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> such as a <a class="reference external" href="http://en.cppreference.com/mwiki/index.php?search=std::vector">std::vector</a>
or <a class="reference external" href="http://en.cppreference.com/mwiki/index.php?search=std::set">std::set</a>, a separate class that
indicates position within the container, with support for
<a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversing</span></a> through all
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a> in the container.</p>
</dd>
<dt id="term-kd-tree">kd tree</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>discriminator :label: uses</p>
</dd>
</dl>
<p>A <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> that uses a binary tree to
store a collection of data records based on their (point)
location in space.
It uses the concept of a <a class="reference internal" href="#term-discriminator"><span class="xref std std-term">discriminator</span></a> at each level to
decide which single component of the
<a class="reference internal" href="#term-multi-dimensional-search-key"><span class="xref std std-term">multi-dimensional search key</span></a> to branch on at that level.
It uses a <a class="reference internal" href="#term-key-space-decomposition"><span class="xref std std-term">key-space decomposition</span></a>, meaning that all data
records in the left subtree of a node have a value on the
corresponding discriminator that is less than that of the node,
while all data records in the right subtree have a greater
value.</p>
</dd>
<dt id="term-key">key</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>key space :label: has</p>
</dd>
</dl>
<p>A field or part of a larger record used to represent that record
for the purpose of searching or comparing.</p>
</dd>
<dt id="term-key-sort">key sort</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>key :label: uses</p>
</dd>
</dl>
<p>Any sorting operation applied to a collection of
<a class="reference internal" href="#term-key-value-pair"><span class="xref std std-term">key-value pairs</span></a> where the value in this
case is a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to a complete record (that is, a
pointer to the record in memory or a position for a record on
disk).
This is in contrast to a sorting operation that works directly
on a collection of records.
The intention is that the collection of key-value pairs is far
smaller than the collection of records themselves.
As such, this might allow for an <a class="reference internal" href="#term-internal-sort"><span class="xref std std-term">internal sort</span></a> when
sorting the records directly would require an <a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external
sort</span></a>.
The collection of key-value pairs can also act as an
<a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a>.</p>
</dd>
<dt id="term-key-space">key space</dt><dd><p>The range of values that a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value may take on.</p>
</dd>
<dt id="term-key-space-decomposition">key-space decomposition</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>object-space decomposition :label: type</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>image-space decomposition :label: type</p>
</dd>
</dl>
<p>The idea that the range for a <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> will be split
into pieces.
There are two general approaches to this:
<a class="reference internal" href="#term-object-space-decomposition"><span class="xref std std-term">object-space decomposition</span></a> and
<a class="reference internal" href="#term-image-space-decomposition"><span class="xref std std-term">image-space decomposition</span></a>.</p>
</dd>
<dt id="term-key-value-pair">key-value pair</dt><dd><p>A standard solution for solving the problem of how to relate a
<a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value to a record (or how to find the key for a
given record) within the context of a particular index.
The idea is to simply store as records in the index pairs of
keys and records.
Specifically, the index will typically store a copy of the key
along with a reference to the record.
The other standard solution to this problem is to pass a
<a class="reference internal" href="#term-comparator"><span class="xref std std-term">comparator</span></a> function to the index.</p>
</dd>
<dt id="term-language">language</dt><dd><p>A set of strings with specific meanings.</p>
</dd>
<dt id="term-leaf-node">leaf node</dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, leaf node is any node that has two
empty <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
(Note that a binary tree is defined so that every
node has two children, and that is why the leaf node has to have
two empty children, rather than no children.)
In a general tree, any node is a leaf node if it has no children.</p>
</dd>
<dt id="term-level">level</dt><dd><p>In a tree, all nodes of <a class="reference internal" href="#term-depth"><span class="xref std std-term">depth</span></a> <span class="math notranslate nohighlight">\(d\)</span> are at
level <span class="math notranslate nohighlight">\(d\)</span> in the tree.
The root is the only node at level 0, and its depth is 0.</p>
</dd>
<dt id="term-lexical-analysis">lexical analysis</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>interpreter :label: is</p>
</dd>
</dl>
<p>A phase of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> or <a class="reference internal" href="#term-interpreter"><span class="xref std std-term">interpreter</span></a> responsible
for reading in characters of the program or language and grouping
them into <a class="reference internal" href="#term-token"><span class="xref std std-term">tokens</span></a>.</p>
</dd>
<dt id="term-lexical-scoping">lexical scoping</dt><dd><p>Within programming languages, the convention of allowing access
to a variable only within the block of code in which the
variable is defined.
A synonym for static scoping.</p>
</dd>
<dt id="term-lifetime">lifetime</dt><dd><p>For a variable, lifetime is the amount of time it will exist
before it is destroyed.</p>
</dd>
<dt id="term-LIFO">LIFO</dt><dd><p>Abbreviation for “Last-In, First-Out”.
This is the access paradigm for a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a>,
and an old terminolgy for the stack is “LIFO list”.</p>
</dd>
<dt id="term-linear-growth-rate">linear growth rate</dt><dd><p>For input size <span class="math notranslate nohighlight">\(n\)</span>, a growth rate of <span class="math notranslate nohighlight">\(cn\)</span> (for
<span class="math notranslate nohighlight">\(c\)</span> any positive constant).
In other words, the cost of
the associated function is linear on the input size.</p>
</dd>
<dt id="term-linear-order">linear order</dt><dd><p>Another term for <a class="reference internal" href="#term-total-order"><span class="xref std std-term">total order</span></a>.</p>
</dd>
<dt id="term-linear-probing">linear probing</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is the simplest
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method.
Term <span class="math notranslate nohighlight">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> is simply
<span class="math notranslate nohighlight">\(i\)</span>, meaning that collision resolution works by moving
sequentially through the hash table from the <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a>.
While simple, it is also inefficient, since it quickly leads to
certain free <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> in the hash table having
higher probability of being selected during insertion or
search.</p>
</dd>
<dt id="term-linear-probing-by-steps">linear probing by steps</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method is
a variation on simple <a class="reference internal" href="#term-linear-probing"><span class="xref std std-term">linear probing</span></a>.
Some constant <span class="math notranslate nohighlight">\(c\)</span> is defined such that
term <span class="math notranslate nohighlight">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> is
<span class="math notranslate nohighlight">\(ci\)</span>.
This  means that collision resolution works by moving
sequentially through the hash table from the <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a>
in steps of size <span class="math notranslate nohighlight">\(c\)</span>.
While not much improvement on linear probing, it forms the basis
of another collision resolution method called
<a class="reference internal" href="#term-double-hashing"><span class="xref std std-term">double hashing</span></a>, where each key uses a value for
<span class="math notranslate nohighlight">\(c\)</span> defined by a second <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.</p>
</dd>
<dt id="term-link-error">link error</dt><dd><p>After compiling, a link error occurs when each compilation unit compiles correctly,
but in the next stage, the linker is unable to combine all
the object code into a single valid executable file.
Compare to <a class="reference internal" href="#term-compile-time-error"><span class="xref std std-term">compile-time error</span></a>, <a class="reference internal" href="#term-runtime-error"><span class="xref std std-term">runtime error</span></a>,
and <a class="reference internal" href="#term-semantic-error"><span class="xref std std-term">semantic error</span></a>.</p>
</dd>
<dt id="term-linked-list">linked list</dt><dd><p>An implementation for the list ADT that uses
<a class="reference internal" href="#term-dynamic-memory-allocation"><span class="xref std std-term">dynamic memory allocation</span></a>
of link nodes to store the list elements. Common variants are the
<a class="reference internal" href="#term-singly-linked-list"><span class="xref std std-term">singly linked list</span></a> and <a class="reference internal" href="#term-doubly-linked-list"><span class="xref std std-term">doubly linked list</span></a>.</p>
</dd>
<dt id="term-list">list</dt><dd><p>A finite, ordered sequence of data items known as
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>.
This is close to the mathematical concept of a <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.
Note that “ordered” in this definition means that the list
elements have position.
It does not refer to the relationship
between <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values for the list elements (that is,
“ordered” does not mean “sorted”).</p>
</dd>
<dt id="term-literal">literal</dt><dd><p>In a boolean expression, a <code class="docutils literal notranslate"><span class="pre">literal</span></code> is a
boolean variable or its negation.</p>
<p>In the context of compilers, it is any constant value.
Similar to a <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminal</span></a>.</p>
</dd>
<dt id="term-local-variable">local variable</dt><dd><p>A variable declared within a function or method.
It exists only from the time when the function is called to when
the function exits.
When a function is suspended (due to calling another function),
the function’s local variables are stored in an
<a class="reference internal" href="#term-activation-record"><span class="xref std std-term">activation record</span></a> on the <a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a>.</p>
</dd>
<dt id="term-logical-form">logical form</dt><dd><p>The definition for a data type in terms of an ADT. Contrast to
the <a class="reference internal" href="#term-physical-form"><span class="xref std std-term">physical form</span></a> for the data type.</p>
</dd>
<dt id="term-low-level-language">low-level language</dt><dd><p>A programming language that is designed to be easy for a computer to
execute; also called machine language or assembly language.</p>
</dd>
<dt id="term-lower-bound">lower bound</dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> that is
always less than or equal to the growth rate of the
<a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> in question.
In practice, this is the fastest-growing function that we know
grows no faster than all but a constant number of inputs.
It could be a gross under-estimate of the truth.
Since the lower bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> or
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>), we typically have to specify which
situation we are referring to.</p>
</dd>
<dt id="term-lower-bounds-proof">lower bounds proof</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>adversary argument :label: example</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>sorting lower bound :label: example</p>
</dd>
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>search lower bound :label: example</p>
</dd>
</dl>
<p>A proof regarding the lower bound, with this term most typically
referring to the lower bound for any possible algorithm to solve
a given <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.
Many problems have a simple lower bound based on the concept
that the minimum amount of processing is related to looking at
all of the problem’s input.
However, some problems have a higher lower bound than that.
For example, the lower bound for the problem of sorting
(<span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span>) is greater than the input size to
sorting (<span class="math notranslate nohighlight">\(n\)</span>).
Proving such “non-trivial” lower bounds for problems is
notoriously difficult.</p>
</dd>
<dt id="term-lvalue">lvalue</dt><dd><p>An expression that identifies a non-temporary object.</p>
</dd>
<dt id="term-lvalue-reference">lvalue reference</dt><dd><p>An alias or synonymn for an existing object.
Often just referred to as a reference.</p>
</dd>
<dt id="term-map">map</dt><dd><p>A <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> that relates a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> to a
<a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a>.</p>
</dd>
<dt id="term-mapping">mapping</dt><dd><p>A <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> that maps every element of a given
<a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> to a unique element of another set; a
correspondence.</p>
</dd>
<dt id="term-max-heap">max heap</dt><dd><p>A <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> where every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> has a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value
greater than its <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
As a consequence, the node with maximum key value is
at the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-member">member</dt><dd><p>In set notation, this is a synonym for <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>.
In abstract design, a <a class="reference internal" href="#term-data-item"><span class="xref std std-term">data item</span></a> is a member of a <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a>.
In an object-oriented language,
<a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a> are data fields in an
object.</p>
</dd>
<dt id="term-member-function">member function</dt><dd><p>Each operation associated with the ADT is implemented by a
member function or <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>.</p>
</dd>
<dt id="term-memory-leak">memory leak</dt><dd><p>In programming, the act of creating <a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a>.
In languages such as C and C++ that do not support
<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>, repeated memory leaks will evenually
cause the program to terminate.</p>
</dd>
<dt id="term-method">method</dt><dd><p>In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>,
a method is an operation on a <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a>.
A synonym for <a class="reference internal" href="#term-member-function"><span class="xref std std-term">member function</span></a>.</p>
</dd>
<dt id="term-min-heap">min heap</dt><dd><p>A <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> where every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> has a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value
less than its <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
As a consequence, the node with minimum key value is
at the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-mod">mod</dt><dd><p>Abbreviation for the <a class="reference internal" href="#term-modulus"><span class="xref std std-term">modulus</span></a> function.</p>
</dd>
<dt id="term-modulus">modulus</dt><dd><p>The modulus function returns the
remainder of an integer division.
Sometimes written <span class="math notranslate nohighlight">\(n \bmod m\)</span> in mathematical expressions,
the syntax in many programming languages is <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span></code>.</p>
</dd>
<dt id="term-multi-dimensional-search-key">multi-dimensional search key</dt><dd><p>A search key containing multiple parts, that works in
conjunction with a <a class="reference internal" href="#term-multi-dimensional-search-structure"><span class="xref std std-term">multi-dimensional search structure</span></a>.
Most typically, a <a class="reference internal" href="#term-spatial"><span class="xref std std-term">spatial</span></a> search key representing a
position in multi-dimensional (2 or 3 dimensions) space.
But a multi-dimensional key could be used to organize data within
non-spatial dimensions, such as temperature and time.</p>
</dd>
<dt id="term-multi-dimensional-search-structure">multi-dimensional search structure</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>multi-dimensional search key :label: uses</p>
</dd>
</dl>
<p>A data structure used to support efficient search on a
<a class="reference internal" href="#term-multi-dimensional-search-key"><span class="xref std std-term">multi-dimensional search key</span></a>.
The main concept here is that a multi-dimensional search
structure works more efficiently by considering the multiple
parts of the search key as a whole, rather than making
independent searches on each one-dimensional component of the
key.
A primary example is a <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> that can
efficiently represent and search for records in
multi-dimensional space.</p>
</dd>
<dt id="term-multilist">multilist</dt><dd><p>A list that may contain sublists.
This term is sometimes used as a synonym to the term
<a class="reference internal" href="#term-bag"><span class="xref std std-term">bag</span></a>.</p>
</dd>
<dt id="term-name">name</dt><dd><p>See <a class="reference internal" href="#term-identifier"><span class="xref std std-term">identifier</span></a>.</p>
</dd>
<dt id="term-natural-language">natural language</dt><dd><p>Any one of the languages that people speak that evolved naturally.</p>
</dd>
<dt id="term-natural-order">natural order</dt><dd><p>An ordering of a sequence of objects that seems ‘natural’ to most people.
The ‘natural order’ of whole numbers is the sequence used to count things:
1,2,3,4,5,6…
The natural order for words is sorted alphabetically.</p>
</dd>
<dt id="term-neighbor">neighbor</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>adjacent :label: is</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>graph :label: context</p>
</dd>
</dl>
<p>In a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>, a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(w\)</span> is said to be a
neighbor of <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(v\)</span> if there is an <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a>
from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(w\)</span>.</p>
</dd>
<dt id="term-node">node</dt><dd><p>The objects that make up a linked structure such as a linked
list or binary tree.
Typically, nodes are allocated using
<a class="reference internal" href="#term-dynamic-memory-allocation"><span class="xref std std-term">dynamic memory allocation</span></a>.</p>
</dd>
<dt id="term-non-strict-partial-order">non-strict partial order</dt><dd><p>In set notation, a relation that is <a class="reference internal" href="#term-reflexive"><span class="xref std std-term">reflexive</span></a>,
<a class="reference internal" href="#term-antisymmetric"><span class="xref std std-term">antisymmetric</span></a>, and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.</p>
</dd>
<dt id="term-non-terminal">non-terminal</dt><dd><p>In contrast to a <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminal</span></a>, a non-terminal is an abstract
state in a <a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rule</span></a>. Begining with the
<a class="reference internal" href="#term-start-symbol"><span class="xref std std-term">start symbol</span></a>, all non-terminals must be converted into
terminals in order to complete a <a class="reference internal" href="#term-derivation"><span class="xref std std-term">derivation</span></a>.</p>
</dd>
<dt id="term-object">object</dt><dd><p>An instance of a class, that is, something that is created and
takes up storage during the execution of a computer program.
In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>, objects
are the basic units of operation.
Objects have state in the form of <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a>,
and they know how to perform certain actions
(<a class="reference internal" href="#term-function"><span class="xref std std-term">functions</span></a>).</p>
</dd>
<dt id="term-object-code">object code</dt><dd><p>The output of the compiler after it translates the program.</p>
</dd>
<dt id="term-object-oriented-programming">object-oriented programming</dt><dt id="term-object-oriented-programming-paradigm">object-oriented programming paradigm</dt><dd><p>An approach to problem-solving where all computations are
carried out using <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>.</p>
</dd>
<dt id="term-object-space-decomposition">object-space decomposition</dt><dd><p>A from of <a class="reference internal" href="#term-key-space-decomposition"><span class="xref std std-term">key-space decomposition</span></a> where the
<a class="reference internal" href="#term-key-space"><span class="xref std std-term">key space</span></a> is determined
by the actual values of keys that are found.
For example,
a binary search tree stores a key value in its root,
and all other values in the tree with lesser value are in the
left <a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtree</span></a>.
Thus, the root value has split (or decomposed) the
key space for that key based on its value into left
and right parts.
An object-space decomposition is in opposition to an
<a class="reference internal" href="#term-image-space-decomposition"><span class="xref std std-term">image-space decomposition</span></a>.</p>
</dd>
<dt id="term-octree">octree</dt><dd><p>The three-dimensional equivalent of the <a class="reference internal" href="#term-quadtree"><span class="xref std std-term">quadtree</span></a> would
be a tree with <span class="math notranslate nohighlight">\(2^3\)</span> or eight branches.</p>
</dd>
<dt id="term-Omega-notation">Omega notation</dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>,
<span class="math notranslate nohighlight">\(\Omega\)</span> notation is used to describe a <a class="reference internal" href="#term-lower-bound"><span class="xref std std-term">lower bound</span></a>.
Roughly (but not completely) analogous to
<a class="reference internal" href="#term-big-Oh-notation"><span class="xref std std-term">big-Oh notation</span></a> used to define an <a class="reference internal" href="#term-upper-bound"><span class="xref std std-term">upper bound</span></a>.</p>
</dd>
<dt id="term-open-addressing">open addressing</dt><dd><p>A synonym for <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hashing</span></a>.</p>
</dd>
<dt id="term-open-hash-system">open hash system</dt><dd><p>A <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a> where multiple records might be associated
with the same slot of a <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
Typically this is done using a linked list to store the records.
This is in contrast to a <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hash system</span></a>.</p>
</dd>
<dt id="term-operating-system">operating system</dt><dd><p>The control program for a computer.
Its purpose is to control hardware, manage resources, and
present a standard interface to these to other software
components.</p>
</dd>
<dt id="term-optimization-problem">optimization problem</dt><dd><p>Any problem where there are a (typically large) collection of
potential solutions, and the goal is to find the best solution.
An example is the Traveling Salesman Problem, where
visiting <span class="math notranslate nohighlight">\(n\)</span> cities in some order has a cost, and the goal
is to visit in the cheapest order.</p>
</dd>
<dt id="term-overflow">overflow</dt><dd><p>The condition where the amount of data stored in an entity has
exceeded its capacity.
For example, a node in a array can store a certain
number of records.
If a record is attempted to be inserted into a node that is
full, then something has to be done to handle this case.</p>
</dd>
<dt id="term-overflow-bucket">overflow bucket</dt><dd><p>In <a class="reference internal" href="#term-bucket-hashing"><span class="xref std std-term">bucket hashing</span></a>, this is the <a class="reference internal" href="#term-bucket"><span class="xref std std-term">bucket</span></a> into which
a record is placed if the bucket containing the record’s
<a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a> is full.
The overflow bucket is logically considered to have infinite
capacity, though in practice search and insert will become
relatively expensive if many records are stored in the overflow
bucket.</p>
</dd>
<dt id="term-parameter">parameter</dt><dt id="term-parameters">parameters</dt><dd><p>The values making up an input to a <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>.</p>
</dd>
<dt id="term-parent">parent</dt><dd><p>In a tree, the <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(P\)</span> that directly links to a
node <span class="math notranslate nohighlight">\(A\)</span> is the parent of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is the
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a> of <span class="math notranslate nohighlight">\(P\)</span>.</p>
</dd>
<dt id="term-parent-pointer-representation">parent pointer representation</dt><dd><p>For <a class="reference internal" href="#term-tree"><span class="xref std std-term">trees</span></a>, a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> implementation where
each node stores only a pointer to its <a class="reference internal" href="#term-parent"><span class="xref std std-term">parent</span></a>, rather
than to its <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
This makes it easy to go up the tree toward the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>,
but not down the tree toward the <a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaves</span></a>.</p>
</dd>
<dt id="term-parity">parity</dt><dd><p>The concept of matching even-ness or odd-ness, the basic idea
behind using a <a class="reference internal" href="#term-parity-bit"><span class="xref std std-term">parity bit</span></a> for error detection.</p>
</dd>
<dt id="term-parity-bit">parity bit</dt><dd><p>A common method for checking if transmission of a
sequence of bits has been performed correctly.
The idea is to count the number of 1 bits in the sequence, and
set the parity bit to 1 if this number is odd, and 0 if it is
even.
Then, the transmitted sequence of bits can be checked to see if
its parity matches the value of the parity bit.
This will catch certain types of errors, in particular if the
value for a single bit has been reversed.
This was used, for example, in early versions of
<a class="reference internal" href="#term-ASCII-character-coding"><span class="xref std std-term">ASCII character coding</span></a>.</p>
</dd>
<dt id="term-parse">parse</dt><dd><p>To examine a program and analyze the syntactic structure.</p>
</dd>
<dt id="term-parse-tree">parse tree</dt><dd><p>A tree that represents the syntactic structure of an input
string, making it easy to compare against a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a> to
see if it is syntactically correct.</p>
</dd>
<dt id="term-parser">parser</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>compiler :label: part of</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>parse tree :label: build</p>
</dd>
</dl>
<p>A part of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that takes as input the program
text (or more typically, the tokens from the <a class="reference internal" href="#term-scanner"><span class="xref std std-term">scanner</span></a>),
and verifies that the program is syntactically correct.
Typically it will build a <a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a> as part of the
process.</p>
</dd>
<dt id="term-partial-order">partial order</dt><dd><p>In set notation, a binary relation is called a partial order if
it is <a class="reference internal" href="#term-antisymmetric"><span class="xref std std-term">antisymmetric</span></a> and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.
If the relation is also <a class="reference internal" href="#term-reflexive"><span class="xref std std-term">reflexive</span></a>, then it is a
<a class="reference internal" href="#term-non-strict-partial-order"><span class="xref std std-term">non-strict partial order</span></a>.
Alternatively, if the relation is also <a class="reference internal" href="#term-irreflexive"><span class="xref std std-term">irreflexive</span></a>, then
it is a <a class="reference internal" href="#term-strict-partial-order"><span class="xref std std-term">strict partial order</span></a>.</p>
</dd>
<dt id="term-partially-ordered-set">partially ordered set</dt><dd><p>The set on which a <a class="reference internal" href="#term-partial-order"><span class="xref std std-term">partial order</span></a> is defined is called a
partially ordered set.</p>
</dd>
<dt id="term-partition">partition</dt><dd><p>The process of splitting a set into two parts, typically centering
around a predicate expression or a value.</p>
<p>In quick sort, the central value is called the <code class="docutils literal notranslate"><span class="pre">pivot</span></code> value.
One partition will contain values less then the pivot,
while the other partition will contain values greater than the
pivot value.</p>
</dd>
<dt id="term-pass-by-reference">pass by reference</dt><dd><p>A <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to the variable is passed to the called
function. So, any modifications will affect the original
variable.</p>
</dd>
<dt id="term-pass-by-value">pass by value</dt><dd><p>A copy of a variable is passed to the called function. So, any
modifications will not affect the original variable.</p>
</dd>
<dt id="term-path">path</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>tree :label: In</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>vertex :label: sequence of</p>
</dd>
</dl>
<p>In <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology,
a sequence of <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a>
<span class="math notranslate nohighlight">\(v_1, v_2, ..., v_n\)</span>
forms a path of length <span class="math notranslate nohighlight">\(n-1\)</span> if there exist edges from
<span class="math notranslate nohighlight">\(v_i\)</span> to <span class="math notranslate nohighlight">\(v_{i+1}\)</span> for <span class="math notranslate nohighlight">\(1 \leq i &lt; n\)</span>.</p>
</dd>
<dt id="term-permutation">permutation</dt><dd><p>A permutation of a sequence <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>
is the <a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a> of <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> arranged
in some order.</p>
</dd>
<dt id="term-physical-form">physical form</dt><dd><p>The implementation of a data type as a data structure.
Contrast to the <a class="reference internal" href="#term-logical-form"><span class="xref std std-term">logical form</span></a> for the data type.</p>
</dd>
<dt id="term-Pigeonhole-Principle">Pigeonhole Principle</dt><dd><p>A commonly used lemma in Mathematics. A typical variant states:
When <span class="math notranslate nohighlight">\(n+1\)</span> objects are stored in <span class="math notranslate nohighlight">\(n\)</span> locations, at
least one of the locations must store two or more of the objects.</p>
</dd>
<dt id="term-POD">POD</dt><dd><p>An abbreviation for ‘plain old data’.
Used to indicate a data structure containing no member functions
and only publicly accessible data.</p>
</dd>
<dt id="term-pointer">pointer</dt><dd><p>A variable whose value is the <a class="reference internal" href="#term-address"><span class="xref std std-term">address</span></a> of another variable;
a link.</p>
</dd>
<dt id="term-pointer-based-implementation-for-binary-tree-nodes">pointer-based implementation for binary tree nodes</dt><dd><p>A common way to implement <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a>.
Each node stores a data value (or a reference to a data value),
and pointers to the left and right children.
If either or both of the children does not exist, then a null
pointer is stored.</p>
</dd>
<dt id="term-polymorphism">polymorphism</dt><dt id="term-Polymorphism">Polymorphism</dt><dd><p>An <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>
term meaning <em>one name, many forms</em>.
It describes the ability of software to change its behavior
dynamically.  Two basic forms exist:
<a class="reference internal" href="#term-runtime-polymorphism"><span class="xref std std-term">runtime polymorphism</span></a> and <a class="reference internal" href="#term-compile-time-polymorphism"><span class="xref std std-term">compile-time polymorphism</span></a>.</p>
</dd>
<dt id="term-pop">pop</dt><dd><p>A specialized term used to indicate removing an <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>
from a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a>.</p>
</dd>
<dt id="term-portability">portability</dt><dd><p>A property of a program that can run on more than one kind of computer.</p>
</dd>
<dt id="term-poset">poset</dt><dd><p>An abbreviation for a <a class="reference internal" href="#term-partially-ordered-set"><span class="xref std std-term">partially ordered set</span></a>.</p>
</dd>
<dt id="term-position">position</dt><dd><p>The defining property of the list ADT, this is the concept that
list elements are in a position. Many list ADTs support access
by position.</p>
</dd>
<dt id="term-postorder-traversal">postorder traversal</dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> that first
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> <a class="reference internal" href="#term-visit"><span class="xref std std-term">visits</span></a> the left
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a>,
then recursively visits the right child, and then visits the
<a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-powerset">powerset</dt><dd><p>For a <a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, the power set is the set
of all possible <a class="reference internal" href="#term-subset"><span class="xref std std-term">subsets</span></a> for <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>.</p>
</dd>
<dt id="term-PR-quadtree">PR quadtree</dt><dd><p>A type of <a class="reference internal" href="#term-quadtree"><span class="xref std std-term">quadtree</span></a> that stores point data in two
dimensions.
The root of the PR quadtree represents some square region of 2d
space.
If that space stores more than one data point, then the region
is decomposed into four equal subquadrants, each represented
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> by a subtree of the PR quadtree.
Since many leaf nodes of the PR quadtree will contain no data
points, implementation often makes use of the <a class="reference internal" href="#term-flyweight"><span class="xref std std-term">flyweight</span></a>
<a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a>.
Related to the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>.</p>
</dd>
<dt id="term-predicate">predicate</dt><dt id="term-predicate-function">predicate function</dt><dd><p>A function that returns a boolean value.</p>
</dd>
<dt id="term-preorder-traversal">preorder traversal</dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> that first
<a class="reference internal" href="#term-visit"><span class="xref std std-term">visits</span></a> the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>, then
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> visits the left <a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a>,
then recursively visits the right child.</p>
</dd>
<dt id="term-primary-clustering">primary clustering</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the tendency in certain
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
methods to create clustering in sections of the hash table.
The classic example is <a class="reference internal" href="#term-linear-probing"><span class="xref std std-term">linear probing</span></a>.
This tends to happen when a group of keys follow the same
:term`probe sequence` during collision resolution.</p>
</dd>
<dt id="term-primitive-element">primitive element</dt><dd><p>In set notation, this is a single element that is a member of
the base type for the set. This is as opposed to an element of
the set being another set.</p>
</dd>
<dt id="term-primitive-type">primitive type</dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> whose values contain no subparts.
An example is the integers.
A synonym for <a class="reference internal" href="#term-simple-type"><span class="xref std std-term">simple type</span></a>
and <a class="reference internal" href="#term-code-block"><span class="xref std std-term">code block</span></a>.</p>
</dd>
<dt id="term-priority">priority</dt><dd><p>A quantity assigned to each of a collection of
tasks that indicate importance for order of processing.
For example, in an operating system, there could be a collection
of processes (jobs) ready to run.
The operating system must select the next task to execute,
based on their priorities.</p>
</dd>
<dt id="term-priority-queue">priority queue</dt><dd><p>An ADT whose primary operations of insert of records, and
deletion of the greatest (or, in an alternative implementation,
the least) valued record.
Most often implemented using the <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> data structure.
The name comes from a common application where the records being
stored represent tasks, with the ordering values based on the
<a class="reference internal" href="#term-priority"><span class="xref std std-term">priorities</span></a> of the tasks.</p>
</dd>
<dt id="term-probe-function">probe function</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the function used by a
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method to calculate where to look
next in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.</p>
</dd>
<dt id="term-probe-sequence">probe sequence</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the series of <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> visited
by the <a class="reference internal" href="#term-probe-function"><span class="xref std std-term">probe function</span></a> during
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>.</p>
</dd>
<dt id="term-problem">problem</dt><dd><p>A task to be performed.
It is best thought of as a <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> or a mapping of
inputs to outputs.</p>
</dd>
<dt id="term-problem-instance">problem instance</dt><dd><p>A specific selection of values for the parameters to a problem.
In other words, a specific set of inputs to a problem.
A given problem instance has a size under some
<a class="reference internal" href="#term-cost-model"><span class="xref std std-term">cost model</span></a>.</p>
</dd>
<dt id="term-problem-solving">problem solving</dt><dd><p>The process of formulating a problem, finding a solution, and
expressing the solution.</p>
</dd>
<dt id="term-procedural">procedural</dt><dd><p>Typically referring to the
<a class="reference internal" href="#term-procedural-programming-paradigm"><span class="xref std std-term">procedural programming paradigm</span></a>, in contrast to the
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>.</p>
</dd>
<dt id="term-procedural-programming-paradigm">procedural programming paradigm</dt><dd><p>Procedural programming uses a list of instructions (and
procedure calls) that define a series of computational steps to
be carried out.
This is in contrast to the
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>.</p>
</dd>
<dt id="term-production">production</dt><dt id="term-production-rule">production rule</dt><dd><p>A <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a> is comprised of production rules.
The production rules consist of <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminals</span></a> and
<a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminals</span></a>, with one of the non-terminals
being the <a class="reference internal" href="#term-start-symbol"><span class="xref std std-term">start symbol</span></a>.
Each production rule replaces one or more non-terminals (perhaps
with associated terminals) with one or more terminals and
non-terminals.
Depending on the restrictions placed on the form of the rules,
there are classes of languages that can be represented by
specific types of grammars.
A <a class="reference internal" href="#term-derivation"><span class="xref std std-term">derivation</span></a> is a series of productions that results in
a string (that is, all non-terminals), and this derivation can
be represented as a <a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a>.</p>
</dd>
<dt id="term-program">program</dt><dd><p>An instance, or concrete representation, of an algorithm in some
programming language.
A sequence of instructions that specifies to a computer actions and
computations to be performed.
A program can refer to the <a class="reference internal" href="#term-compile"><span class="xref std std-term">compiled</span></a> system
<a class="reference internal" href="#term-object-code"><span class="xref std std-term">object code</span></a>, or to the original <a class="reference internal" href="#term-source-code"><span class="xref std std-term">source code</span></a>.</p>
</dd>
<dt id="term-programming-language">programming language</dt><dd><p>A formal notation for representing solutions.</p>
</dd>
<dt id="term-proof">proof</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>lower bounds proof :label: example</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>NP-Completeness proof :label: example</p>
</dd>
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>proof by contradiction :label: type</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>proof by induction :label: type</p>
</dd>
</dl>
<p>The establishment of the truth of anything, a demonstration.</p>
</dd>
<dt id="term-proof-by-contradiction">proof by contradiction</dt><dd><p>A mathematical proof technique that proves a theorem by first
assuming that the theorem is false, and then uses a chain of
reasoning to reach a logical contradiction.
Since when the theorem is false a logical contradiction arises,
the conclusion is that the theorem must be true.</p>
</dd>
<dt id="term-proof-by-induction">proof by induction</dt><dd><p>A mathematical proof technique similar to <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>.
It is used to prove a parameterized theorem $S(n)$, that is,
a theorem where there is a induction variable involved
(such as the sum of the numbers from 1 to $n$).
One first proves that the theorem holds true for a
<a class="reference internal" href="#term-base-case"><span class="xref std std-term">base case</span></a>, then one proves the implication that
whenever $S(n)$ is true then $S(n+1)$ is also true.
Another variation is <a class="reference internal" href="#term-strong-induction"><span class="xref std std-term">strong induction</span></a>.</p>
</dd>
<dt id="term-pseudo-random-probing">pseudo-random probing</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is a <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
method that stores a random permutation of the values 1 through
the size of the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
Term <span class="math notranslate nohighlight">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> is simply the value
of position <span class="math notranslate nohighlight">\(i\)</span> in the permuation.</p>
</dd>
<dt id="term-push">push</dt><dd><p>A specialized term used to indicate inserting an <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>
onto a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a>.</p>
</dd>
<dt id="term-push_back">push_back</dt><dd><p>A specialized term used to indicate appending an <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>
onto a <a class="reference internal" href="#term-vector"><span class="xref std std-term">vector</span></a>.</p>
</dd>
<dt id="term-quadratic-growth-rate">quadratic growth rate</dt><dd><p>A growth rate function of the form <span class="math notranslate nohighlight">\(cn^2\)</span> where <span class="math notranslate nohighlight">\(n\)</span>
is the input size and <span class="math notranslate nohighlight">\(c\)</span> is a constant.</p>
</dd>
<dt id="term-quadratic-probing">quadratic probing</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is a <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
method that computes term <span class="math notranslate nohighlight">\(i\)</span> of the
<a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> using some quadratic equation
<span class="math notranslate nohighlight">\(ai^2 _ bi + c\)</span> for suitable constants <span class="math notranslate nohighlight">\(a, b, c\)</span>.
The simplest form is simply to use <span class="math notranslate nohighlight">\(i^2\)</span> as term <span class="math notranslate nohighlight">\(i\)</span>
of the probe sequence.</p>
</dd>
<dt id="term-quadtree">quadtree</dt><dd><p>A <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full tree</span></a> where each internal node has four children.
Most typically used to store two dimensional
<a class="reference internal" href="#term-spatial-data"><span class="xref std std-term">spatial data</span></a>.
Related to the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>.
The difference is that the quadtree splits all dimensions
simultaneously, while the bintree splits one dimension at each
level.
Thus, to extend the quadtree concept to more dimensions requires
a rapid increase in the number of splits (for example, 8 in
three dimensions).</p>
</dd>
<dt id="term-queue">queue</dt><dd><p>A list-like structure in which elements are inserted only at one
end, and removed only from the other one end.</p>
</dd>
<dt id="term-radix">radix</dt><dd><p>Synonym for <a class="reference internal" href="#term-base"><span class="xref std std-term">base</span></a>. The number of digits in a number
representation. For example, we typically represent numbers in
base (or radix) 10. Hexidecimal is base (or radix) 16.</p>
</dd>
<dt id="term-RAII">RAII</dt><dd><p>Resource Acquisition Is Initialization
is the C++ term for a programming style in which critical resources are
tied to the object which owns them.
Because they are typically allocated in class constructors and
destroyed in class destructors, in other languages, this is
sometimes called <em>Constructor Acquires, Destructor Releases</em></p>
</dd>
<dt id="term-range">range</dt><dd><p>The set of possible outputs for a function.</p>
</dd>
<dt id="term-record">record</dt><dd><p>A collection of information, typically implemented as an
<a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> in an
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming language</span></a>.
Many data structures are organized containers for a collection
of records.</p>
</dd>
<dt id="term-recursion">recursion</dt><dd><p>The process of using recursive calls.
An algorithm is recursive if it calls itself to do part of
its work.
See <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>.</p>
</dd>
<dt id="term-recursive-call">recursive call</dt><dd><p>Within a <a class="reference internal" href="#term-recursive-function"><span class="xref std std-term">recursive function</span></a>, it is a call that the
function makes to itself.</p>
</dd>
<dt id="term-recursive-data-structure">recursive data structure</dt><dd><p>A data structure that is partially
composed of smaller or simpler instances of the same data structure.
For example, <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked lists</span></a> and
<a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary trees</span></a> can be viewed as recursive
data structures.</p>
</dd>
<dt id="term-recursive-function">recursive function</dt><dd><p>A function that includes a <a class="reference internal" href="#term-recursive-call"><span class="xref std std-term">recursive call</span></a>.</p>
</dd>
<dt id="term-reference">reference</dt><dd><p>A value that enables a program to directly access some
particular data item.
An example might be a byte position within a file where the
record is stored, or a pointer to a record in memory.
(Note that Java makes a distinction between a reference and the
concept of a pointer, since it does not define a reference to
necessarily be a byte position in memory.)</p>
</dd>
<dt id="term-reference-count-algorithm">reference count algorithm</dt><dd><p>An algorithm for <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>.
Whenever a reference is made from a variable to some memory
location, a counter associated with that memory location is
incremented.
Whenever the reference is changed or deleted, the reference
count is decremented.
If this count goes to zero, then the memory is considered free
for reuse.
This approach can fail if there is a cycle in the chain of
references.</p>
</dd>
<dt id="term-reflexive">reflexive</dt><dd><p>In set notation, binary relation <span class="math notranslate nohighlight">\(R\)</span> on set <span class="math notranslate nohighlight">\(S\)</span> is
reflexive if <span class="math notranslate nohighlight">\(aRa\)</span> for all <span class="math notranslate nohighlight">\(a \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-regular-type">regular type</dt><dd><p>A user defined <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> that behaves like a ‘regular’
built-in (fundamental) type.
Regular types support the following operations:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 56%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Default constructor</p></td>
<td><p>T a;</p></td>
</tr>
<tr class="row-odd"><td><p>Copy constructor</p></td>
<td><p>T a = b;</p></td>
</tr>
<tr class="row-even"><td><p>Destructor</p></td>
<td><p>~T (a);</p></td>
</tr>
<tr class="row-odd"><td><p>Assignment</p></td>
<td><p>a = b;</p></td>
</tr>
<tr class="row-even"><td><p>Equality</p></td>
<td><p>a == b;</p></td>
</tr>
<tr class="row-odd"><td><p>Inequality</p></td>
<td><p>a != b;</p></td>
</tr>
<tr class="row-even"><td><p>Ordering</p></td>
<td><p>a &lt; b;</p></td>
</tr>
</tbody>
</table>
</dd>
<dt id="term-relation">relation</dt><dd><p>In set notation, a relation <span class="math notranslate nohighlight">\(R\)</span> over set
<span class="math notranslate nohighlight">\(\mathbf{S}\)</span> is a set of ordered pairs from
<span class="math notranslate nohighlight">\(\mathbf{S}\)</span>.</p>
</dd>
<dt id="term-root">root</dt><dd><p>In a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, the topmost <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> of the tree.
All other nodes in the tree are <a class="reference internal" href="#term-descendant"><span class="xref std std-term">descendants</span></a>
of the root.</p>
</dd>
<dt id="term-runtime-environment">runtime environment</dt><dd><p>The environment in which a program (of a particular programming
language) executes.
The runtime environment handles such activities as managing the
<a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a>, the <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>, and the
<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collector</span></a>,
and it conducts the execution of the program.</p>
</dd>
<dt id="term-runtime-error">runtime error</dt><dd><p>An error that does not occur until the program has started to execute
but that prevents the program from continuing.
Compare to <a class="reference internal" href="#term-compile-time-error"><span class="xref std std-term">compile-time error</span></a>, <a class="reference internal" href="#term-link-error"><span class="xref std std-term">link error</span></a>,
and <a class="reference internal" href="#term-semantic-error"><span class="xref std std-term">semantic error</span></a>.</p>
</dd>
<dt id="term-runtime-polymorphism">runtime polymorphism</dt><dt id="term-Runtime-polymorphism">Runtime polymorphism</dt><dd><p>A form of <a class="reference internal" href="#term-polymorphism"><span class="xref std std-term">polymorphism</span></a> known as Overriding.
Overridden methods are those which implement a new method
with the same signature as a method inherited from its
base class.
Compare to <a class="reference internal" href="#term-compile-time-polymorphism"><span class="xref std std-term">compile-time polymorphism</span></a>.</p>
</dd>
<dt id="term-runtime-stack">runtime stack</dt><dd><p>The place where an <a class="reference internal" href="#term-activation-record"><span class="xref std std-term">activation record</span></a> is stored when a
subroutine is called during a program’s runtime.</p>
</dd>
<dt id="term-rvalue">rvalue</dt><dd><p>An expression that identifies a temporary object or
a value not associated with any object, such as a literal.</p>
</dd>
<dt id="term-rvalue-reference">rvalue reference</dt><dd><p>Sometimes called a forwarding reference.
A reference that is allowed to refer to an rvalue.
That is, a temporary object or an rvalue not associated with any object.</p>
</dd>
<dt id="term-scanner">scanner</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>compiler :label: part of</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>lexical analysis :label: responsible for</p>
</dd>
</dl>
<p>The part of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that is responsible for doing
<a class="reference internal" href="#term-lexical-analysis"><span class="xref std std-term">lexical analysis</span></a>.</p>
</dd>
<dt id="term-scope">scope</dt><dd><p>A region of the program where a defined variable, definition, or function exists.
Beyond that point the variable can not be accessed.</p>
</dd>
<dt id="term-search-key">search key</dt><dd><p>A field or part of a record that is used to represent the record
when searching. For example, in a database of customer records,
we might want to search by name.
In this case the name field is used as the search key.</p>
</dd>
<dt id="term-search-lower-bound">search lower bound</dt><dd><p>The problem of searching in an array has provable lower bounds
for specific variations of the problem.
For an unsorted array, it is <span class="math notranslate nohighlight">\(\Omega(n)\)</span>
<a class="reference internal" href="#term-comparison"><span class="xref std std-term">comparisons</span></a> in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>,
typically proved using an <a class="reference internal" href="#term-adversary-argument"><span class="xref std std-term">adversary argument</span></a>.
For a sorted array, it is <span class="math notranslate nohighlight">\(\Omega(\log n)\)</span> in the worst
case, typically proved using an argument similar to the
<a class="reference internal" href="#term-sorting-lower-bound"><span class="xref std std-term">sorting lower bound</span></a> proof.
However, it is possible to search a sorted array in the average
case in <span class="math notranslate nohighlight">\(O(\log \log n)\)</span> time.</p>
</dd>
<dt id="term-search-problem">search problem</dt><dd><p>Given a particular key value <span class="math notranslate nohighlight">\(K\)</span>, the search problem is to
locate a <a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a> <span class="math notranslate nohighlight">\((k_j, I_j)\)</span> in some collection of
records <strong>L</strong> such that <span class="math notranslate nohighlight">\(k_j = K\)</span> (if one exists).
<a class="reference internal" href="#term-searching"><span class="xref std std-term">Searching</span></a> is a systematic method for
locating the record (or records) with key value <span class="math notranslate nohighlight">\(k_j = K\)</span>.</p>
</dd>
<dt id="term-search-tree">search tree</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>Binary Search Tree :label: example</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>search trie :label: example</p>
</dd>
</dl>
<p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> data structure that makes search by <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a>
value more efficient.
A type of <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a>, it is common to implement an
<a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a> using a search tree.
A good search tree implementation will guarantee that insertion,
deletion, and search operations are all <span class="math notranslate nohighlight">\(\Theta(\log n)\)</span>.</p>
</dd>
<dt id="term-search-trie">search trie</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>alphabet trie :label: example</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>binary trie :label: example</p>
</dd>
</dl>
<p>Any <a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search tree</span></a> that is a <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>.</p>
</dd>
<dt id="term-searching">searching</dt><dd><p>Given a <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> <span class="math notranslate nohighlight">\(K\)</span> and some collection of
records <strong>L</strong>, searching is a systematic method for locating the
record (or records) in <strong>L</strong> with key value <span class="math notranslate nohighlight">\(k_j = K\)</span>.</p>
</dd>
<dt id="term-secondary-clustering">secondary clustering</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the tendency in certain
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
methods to create clustering in sections of the hash table.
In <a class="reference internal" href="#term-primary-clustering"><span class="xref std std-term">primary clustering</span></a>, this is caused by a cluster of
keys that don’t necessarily hash to the same slot but which
following significant portions of the same
<a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> during collision resolution.
Secondary clustering results from the keys hashing to the same
slot of the table (and so a collision resolution method that is
not affected by the key value must use the same probe sequence
for all such keys).
This problem can be resolved by <a class="reference internal" href="#term-double-hashing"><span class="xref std std-term">double hashing</span></a> since its
probe sequence is determined in part by a second hash function.</p>
</dd>
<dt id="term-semantic-error">semantic error</dt><dd><p>An error in a program or expression that makes it do something other than what the
programmer intended.
Compare to <a class="reference internal" href="#term-compile-time-error"><span class="xref std std-term">compile-time error</span></a>, <a class="reference internal" href="#term-link-error"><span class="xref std std-term">link error</span></a>,
and <a class="reference internal" href="#term-runtime-error"><span class="xref std std-term">runtime error</span></a>.</p>
</dd>
<dt id="term-semantics">semantics</dt><dd><p>The meaning of a program or piece of text.</p>
</dd>
<dt id="term-separate-chaining">separate chaining</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a synonym for
<a class="reference internal" href="#term-open-hash-system"><span class="xref std std-term">open hashing</span></a></p>
</dd>
<dt id="term-sequence">sequence</dt><dd><p>In set notation, a collection of elements with an order, and
which may contain duplicate-valued elements.
A sequence is also sometimes called a <a class="reference internal" href="#term-tuple"><span class="xref std std-term">tuple</span></a> or a
<a class="reference internal" href="#term-vector"><span class="xref std std-term">vector</span></a>.</p>
</dd>
<dt id="term-sequence-container">sequence container</dt><dd><p>A container in which elements can be accessed sequentially.
The underlying data may be a contiguous block of memory,
as with <code class="docutils literal notranslate"><span class="pre">vector</span></code> and <code class="docutils literal notranslate"><span class="pre">array</span></code>,
or may be non-contiguous memory, as with <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
</dd>
<dt id="term-sequential-tree-representation">sequential tree representation</dt><dd><p>A representation that stores a series of node values with the
minimum information needed to reconstruct the tree structure.
This is a technique for <a class="reference internal" href="#term-serialization"><span class="xref std std-term">serializing</span></a> a
tree.</p>
</dd>
<dt id="term-serialization">serialization</dt><dd><p>The process of taking a data structure in memory and
representing it as a sequence of bytes.
This is sometimes done in order to transmit the data structure
across a network or store the data structure in a
<a class="reference internal" href="#term-stream"><span class="xref std std-term">stream</span></a>, such as on disk.
<a class="reference internal" href="#term-deserialization"><span class="xref std std-term">Deserialization</span></a> reconstructs the
original data structure from the serialized representation.</p>
</dd>
<dt id="term-set">set</dt><dd><p>A collection of distinguishable <a class="reference internal" href="#term-member"><span class="xref std std-term">members</span></a> or
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>.</p>
</dd>
<dt id="term-set-former">set former</dt><dd><p>A way to define the membership of a set, by using a text
description.
Example: <span class="math notranslate nohighlight">\(\{x\ |\ x\ \mbox{is a positive integer}\}\)</span>.</p>
</dd>
<dt id="term-set-product">set product</dt><dd><p>Written <span class="math notranslate nohighlight">\(\mathbf{Q} \times \mathbf{P}\)</span>, the set product is
a set of ordered pairs such that ordered pair <span class="math notranslate nohighlight">\((a, b)\)</span> is
in the product whenever <span class="math notranslate nohighlight">\(a \in \mathbf{P}\)</span> and
<span class="math notranslate nohighlight">\(b \in \mathbf{Q}\)</span>.
For example, when <span class="math notranslate nohighlight">\(\mathbf{P} = \{2, 3, 5\}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{Q} = \{5, 10\}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{Q} \times \mathbf{P} =
\{(2, 5),\ (2, 10),\ (3, 5),\ (3, 10),\ (5, 5),\ (5, 10)\}\)</span>.</p>
</dd>
<dt id="term-shallow-copy">shallow copy</dt><dd><p>Copying a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> or <a class="reference internal" href="#term-pointer"><span class="xref std std-term">pointer</span></a>
value without copying the actual content.</p>
</dd>
<dt id="term-sibling">sibling</dt><dd><p>In a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, a sibling of <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(A\)</span> is any
other node with the same <a class="reference internal" href="#term-parent"><span class="xref std std-term">parent</span></a> as <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt id="term-signature">signature</dt><dd><p>In a programming language, the signature for a function is its
return type and its list of parameters and their types.</p>
</dd>
<dt id="term-simple-type">simple type</dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> whose values contain no subparts.
An example is the integers.
A synonym for <a class="reference internal" href="#term-primitive-type"><span class="xref std std-term">primitive type</span></a>
and :term”<cite>fundamental type</cite>.</p>
</dd>
<dt id="term-simulating-recursion">simulating recursion</dt><dd><p>If a programming language does not support <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>,
or if you want to implement the effects of recursion more
efficiently, you can use a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a> to maintain the
collection of subproblems that
would be waiting for completion during the recursive process.
Using a loop, whenever a recursive call would have been made,
simply add the necessary program state to the stack.
When a return would have been made from the recursive call, pop
the previous program state off of the stack.</p>
</dd>
<dt id="term-singly-linked-list">singly linked list</dt><dd><p>A <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> implementation variant where each list
node contains access an pointer only to the next element in the list.</p>
</dd>
<dt id="term-slot">slot</dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a position in a <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.</p>
</dd>
<dt id="term-software-engineering">software engineering</dt><dd><p>The study and application of engineering to the design,
development, and maintenance of software.</p>
</dd>
<dt id="term-software-reuse">software reuse</dt><dd><p>In <a class="reference internal" href="#term-software-engineering"><span class="xref std std-term">software engineering</span></a>, the concept of reusing a piece
of software.
In particular, using an existing piece of software (such as a
function or library) when creating new software.</p>
</dd>
<dt id="term-sorting-lower-bound">sorting lower bound</dt><dd><p>The lower bound for the <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> of
<a class="reference internal" href="#term-sorting-problem"><span class="xref std std-term">sorting</span></a> is <span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span>.
This is traditionally proved using a <a class="reference internal" href="#term-decision-tree"><span class="xref std std-term">decision tree</span></a> model
for sorting algorithms, and recognizing that the minimum depth
of the decision tree for any sorting algorithm is
<span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span> since there are <span class="math notranslate nohighlight">\(n!\)</span> permutations
of the <span class="math notranslate nohighlight">\(n\)</span> input records to distinguish between during the
sorting process.</p>
</dd>
<dt id="term-sorting-problem">sorting problem</dt><dd><p>Given a set of records <span class="math notranslate nohighlight">\(r_1\)</span>, <span class="math notranslate nohighlight">\(r_2\)</span>, …, <span class="math notranslate nohighlight">\(r_n\)</span>
with <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values <span class="math notranslate nohighlight">\(k_1\)</span>, <span class="math notranslate nohighlight">\(k_2\)</span>, …, <span class="math notranslate nohighlight">\(k_n\)</span>,
the sorting problem is to arrange the records into any order
<span class="math notranslate nohighlight">\(s\)</span> such that records
<span class="math notranslate nohighlight">\(r_{s_1}\)</span>, <span class="math notranslate nohighlight">\(r_{s_2}\)</span>, …, <span class="math notranslate nohighlight">\(r_{s_n}\)</span>
have keys obeying the property
<span class="math notranslate nohighlight">\(k_{s_1} \leq k_{s_2} \leq ... \leq k_{s_n}\)</span>.
In other words, the sorting problem is to arrange a set of
records so that the values of their key fields are in
non-decreasing order.</p>
</dd>
<dt id="term-source-code">source code</dt><dd><p>A program, stored in a file, in a high-level language before being compiled or interpreted.</p>
</dd>
<dt id="term-spatial">spatial</dt><dd><p>Referring to a position in space.</p>
</dd>
<dt id="term-spatial-application">spatial application</dt><dd><p>An application what has spatial aspects.
In particular, an application that stores records that need to
be searched by location.</p>
</dd>
<dt id="term-spatial-attribute">spatial attribute</dt><dd><p>An attribute of a record that has a position in space, such as
the coordinate.
This is typically in two or more dimensions.</p>
</dd>
<dt id="term-spatial-data">spatial data</dt><dd><p>Any object or record that has a position (in space).</p>
</dd>
<dt id="term-spatial-data-structure">spatial data structure</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>bintree :label: example</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>kd tree :label: example</p>
</dd>
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>PR quadtree :label: example</p>
</dd>
</dl>
<p>A <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> designed to support efficient
processing when a
<a class="reference internal" href="#term-spatial-attribute"><span class="xref std std-term">spatial attribute</span></a> is used as the key.
In particular, a data structure that supports efficient search
by location, or finds all records within a given region in two
or more dimensions.
Examples of spatial data structures to store point data include
the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>, the <a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a> and the
<a class="reference internal" href="#term-kd-tree"><span class="xref std std-term">kd tree</span></a>.</p>
</dd>
<dt id="term-stack">stack</dt><dd><p>A list-like structure in which elements may be inserted or
removed from only one end.</p>
</dd>
<dt id="term-start-symbol">start symbol</dt><dd><p>In a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a>, the designated <a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminal</span></a> that
is the initial point for <a class="reference internal" href="#term-derivation"><span class="xref std std-term">deriving</span></a> a string
in the language.</p>
</dd>
<dt id="term-static-scoping">static scoping</dt><dd><p>A synonym for <a class="reference internal" href="#term-lexical-scoping"><span class="xref std std-term">lexical scoping</span></a>.</p>
</dd>
<dt id="term-strategy">strategy</dt><dd><p>An approach to accomplish a task, often encapsulated as an
algorithm.
Also the name for a <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> that separates the
algorithm for performing a task from the control for applying
that task to each member of a collection.
A good example is a generic sorting function that takes a
collection of records (such as an array) and a “strategy” in the
form of an algorithm that knows how to extract the key from a
record in the array.
Only subtly different from the <a class="reference internal" href="#term-visitor"><span class="xref std std-term">visitor</span></a> design pattern,
where the difference is primarily one of intent rather than
syntax.
The strategy design pattern is focused on encapsulating an
activity that is part of a larger process, so that different
ways of performing that activity can be substituted.
The visitor design pattern is focused on encapsulating an
activity that will be performed on all members of a collection
so that completely different activities can be substituted
within a generic method that accesses all of the collection
members.</p>
</dd>
<dt id="term-stream">stream</dt><dd><p>The process of delivering content in a
<a class="reference internal" href="#term-serialization"><span class="xref std std-term">serialized</span></a> form.</p>
</dd>
<dt id="term-strict-partial-order">strict partial order</dt><dd><p>In set notation, a relation that is <a class="reference internal" href="#term-irreflexive"><span class="xref std std-term">irreflexive</span></a>,
<a class="reference internal" href="#term-antisymmetric"><span class="xref std std-term">antisymmetric</span></a>, and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.</p>
</dd>
<dt id="term-strong-induction">strong induction</dt><dd><p>An alternative formulation for the <a class="reference internal" href="#term-induction-step"><span class="xref std std-term">induction step</span></a> in a
<a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">proof by induction</span></a>.
The induction step for strong induction is:
If <strong>Thrm</strong> holds for all <span class="math notranslate nohighlight">\(k, c \leq k &lt; n\)</span>, then
<strong>Thrm</strong> holds for <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
<dt id="term-subclass">subclass</dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
any class within a <a class="reference internal" href="#term-class-hierarchy"><span class="xref std std-term">class hierarchy</span></a> that
<a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherits</span></a> from some other class.
A synonym for <a class="reference internal" href="#term-derived-class"><span class="xref std std-term">derived class</span></a>.</p>
</dd>
<dt id="term-subset">subset</dt><dd><p>In set theory, a set <span class="math notranslate nohighlight">\(A\)</span> is a subset of a set
<span class="math notranslate nohighlight">\(B\)</span>, or equivalently <span class="math notranslate nohighlight">\(B\)</span> is a <a class="reference internal" href="#term-superset"><span class="xref std std-term">superset</span></a> of
<span class="math notranslate nohighlight">\(A\)</span>, if all elements of <span class="math notranslate nohighlight">\(A\)</span> are also elements of
<span class="math notranslate nohighlight">\(B\)</span>.</p>
</dd>
<dt id="term-subtree">subtree</dt><dd><p>A subtree is a subset of the nodes of a binary tree that
includes some node <span class="math notranslate nohighlight">\(R\)</span> of the tree as the subtree
<a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a> along with all the <a class="reference internal" href="#term-descendant"><span class="xref std std-term">descendants</span></a>
of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd>
<dt id="term-superset">superset</dt><dd><p>In set theory, a set <span class="math notranslate nohighlight">\(A\)</span> is a <a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a> of a
<a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> <span class="math notranslate nohighlight">\(B\)</span>, or equivalently <span class="math notranslate nohighlight">\(B\)</span> is a
<a class="reference internal" href="#term-superset"><span class="xref std std-term">superset</span></a> of <span class="math notranslate nohighlight">\(A\)</span>, if all <a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>
of <span class="math notranslate nohighlight">\(A\)</span> are also elements of <span class="math notranslate nohighlight">\(B\)</span>.</p>
</dd>
<dt id="term-symbol-table">symbol table</dt><dd><p>As part of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a>, the symbol table stores all of
the identifiers in the program, along with any necessary
information needed about the identifier to allow the compiler to
do its job.</p>
</dd>
<dt id="term-symmetric">symmetric</dt><dd><p>In set notation, relation <span class="math notranslate nohighlight">\(R\)</span> is symmetric if whenever
<span class="math notranslate nohighlight">\(aRb\)</span>, then <span class="math notranslate nohighlight">\(bRa\)</span>, for all <span class="math notranslate nohighlight">\(a, b \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-symmetric-matrix">symmetric matrix</dt><dd><p>A square matrix that is equal to its <a class="reference internal" href="#term-transpose"><span class="xref std std-term">transpose</span></a>.
Equivalently, for a <span class="math notranslate nohighlight">\(n \times n\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>,
for all <span class="math notranslate nohighlight">\(i,j &lt; n\)</span>, <span class="math notranslate nohighlight">\(A[i, j] = A[j, i]\)</span>.</p>
</dd>
<dt id="term-syntax">syntax</dt><dd><p>The set of rules that defines the valid symbol combinations
that define valid statements or expressions in
a specific language.</p>
</dd>
<dt id="term-syntax-analysis">syntax analysis</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>parse tree :label: generates</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>tokens :label: accepts</p>
</dd>
</dl>
<p>A phase of <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compilation</span></a> that accepts
<a class="reference internal" href="#term-token"><span class="xref std std-term">tokens</span></a>, checks if program is syntactically
correct, and then generates a <a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a>.</p>
</dd>
<dt id="term-syntax-error">syntax error</dt><dd><p>An error in a program that makes it impossible to parse — and
therefore impossible to interpret.</p>
</dd>
<dt id="term-tail">tail</dt><dd><p>The end of a <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a>.</p>
</dd>
<dt id="term-template">template</dt><dd><p>A template is a specific way in C++ to write
<a class="reference internal" href="#term-generic-programming"><span class="xref std std-term">generic</span></a> functions and classes.</p>
<p>A template by itself is not a class, type, function, or any other entity.
It defines a <strong>recipe</strong> for generating a class or function.</p>
</dd>
<dt id="term-terminal">terminal</dt><dd><p>A specific character or string that appears in a
<a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rule</span></a>.
In contrast to a <a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminal</span></a>, which represents an
abstract state in the production.
Similar to a <a class="reference internal" href="#term-literal"><span class="xref std std-term">literal</span></a>, but this is the term more
typically used in the context of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a>.</p>
</dd>
<dt id="term-test-driven-development">test-driven development</dt><dd><p>Test-driven development (TDD) is a software development process
that relies on the repetition of a very short development cycle:
requirements are turned into very specific test cases,
then the software is improved to pass the new tests, only.
This is opposed to software development that allows software to be
added that is not proven to meet requirements.</p>
<p>Kent Beck, who is credited with having developed the technique,
stated in 2003 that TDD encourages simple designs and inspires confidence.</p>
</dd>
<dt id="term-token">token</dt><dd><p>One of the basic elements of the syntactic structure of a program,
analogous to a word in a natural language.</p>
</dd>
<dt id="term-total-order">total order</dt><dd><p>A binary relation on a set where every pair of distinct elements
in the set are <a class="reference internal" href="#term-comparable"><span class="xref std std-term">comparable</span></a> (that is, one can determine
which of the pair is greater than the other).</p>
</dd>
<dt id="term-trailing-return-type">trailing return type</dt><dd><p>A C++11 language feature that allows a function or lambda expression
to defer evaluating the function return type.  Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">mul</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">;}</span>
</pre></div>
</div>
</dd>
<dt id="term-transitive">transitive</dt><dd><p>In set notation, relation <span class="math notranslate nohighlight">\(R\)</span> is transitive if whenever
<span class="math notranslate nohighlight">\(aRb\)</span> and <span class="math notranslate nohighlight">\(bRc\)</span>, then <span class="math notranslate nohighlight">\(aRc\)</span>, for all
<span class="math notranslate nohighlight">\(a, b, c \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-transpose">transpose</dt><dd><p>In the context of linear algebra,
the transpose of a matrix <span class="math notranslate nohighlight">\(A\)</span> is
another matrix <span class="math notranslate nohighlight">\(A^T\)</span> created by writing the rows of
<span class="math notranslate nohighlight">\(A\)</span> as the columns of <span class="math notranslate nohighlight">\(A^T\)</span>.</p>
</dd>
<dt id="term-traversal">traversal</dt><dt id="term-traverse">traverse</dt><dd><p>Any process for visiting all of the objects in a collection
(such as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a>) in some order.</p>
</dd>
<dt id="term-tree">tree</dt><dd><p>A tree <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is a finite set of one or more
<a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> such that there is one designated node
<span class="math notranslate nohighlight">\(R\)</span>, called the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a> of <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>.
If the set <span class="math notranslate nohighlight">\((\mathbf{T} -\{R\})\)</span> is not empty, these
nodes are partitioned into <span class="math notranslate nohighlight">\(n &gt; 0\)</span>
disjoint sets <span class="math notranslate nohighlight">\(\mathbf{T}_0\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{T}_1\)</span>, …, <span class="math notranslate nohighlight">\(\mathbf{T}_{n-1}\)</span>,
each of which is a tree, and whose <a class="reference internal" href="#term-root"><span class="xref std std-term">roots</span></a>
<span class="math notranslate nohighlight">\(R_1, R_2, ..., R_n\)</span>,
respectively, are <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd>
<dt id="term-tree-traversal">tree traversal</dt><dd><p>A <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> performed on a tree.
Traditional tree traversals include
<a class="reference internal" href="#term-preorder-traversal"><span class="xref std std-term">preorder</span></a> and
<a class="reference internal" href="#term-postorder-traversal"><span class="xref std std-term">postorder</span></a> traversals for both
<a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary</span></a> and <a class="reference internal" href="#term-general-tree"><span class="xref std std-term">general</span></a>
trees, and :term`inorder traversal` for binary search trees.</p>
</dd>
<dt id="term-trie">trie</dt><dd><dl class="field-list simple">
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>alphabet trie :label: example</p>
</dd>
<dt class="field-even">to-term</dt>
<dd class="field-even"><p>binary trie :label: example</p>
</dd>
<dt class="field-odd">to-term</dt>
<dd class="field-odd"><p>search trie :label: example</p>
</dd>
</dl>
<p>A form of <a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search tree</span></a> where an internal node represents
a split in the <a class="reference internal" href="#term-key-space"><span class="xref std std-term">key space</span></a> at a predetermined location,
rather than split based on the actual <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values seen.
For example, a simple binary search trie for key values in the
range 0 to 1023 would store all records with key values less
than 512 on the left side of the tree, and all records with key
values equal to or greater than 512 on the right side of the
tree.
A trie is always a <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full tree</span></a>.
Folklore has it that the term comes from “retrieval”, and should
be pronounced as “try” (in contrast to “tree”, to distinguish
the differences in the space decomposition method of a search
tree versus a search trie).
The term “trie” is also sometimes used as a synonym for the
<a class="reference internal" href="#term-alphabet-trie"><span class="xref std std-term">alphabet trie</span></a>.</p>
</dd>
<dt id="term-truth-table">truth table</dt><dd><p>In symbolic logic, a table that contains as rows all possible
combinations of the boolean variables, with a column that shows
the outcome (true or false) for the expression when given that
row’s truth assignment for the boolean variables.</p>
</dd>
<dt id="term-tuple">tuple</dt><dd><p>In set notation, another term for a <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.</p>
<p>In C++, the class <a class="reference external" href="https://en.cppreference.com/w/cpp/utility/tuple">tuple</a>.</p>
</dd>
<dt id="term-two-s-complement">two’s complement</dt><dd><p>A mathematical operation on binary numbers,
as well as a binary signed number representation based on this operation.</p>
</dd>
<dt id="term-type">type</dt><dd><p>A collection of values.</p>
</dd>
<dt id="term-unary-function">unary function</dt><dd><p>A function that accepts one parameter.</p>
</dd>
<dt id="term-unit-test">unit test</dt><dd><p>A software test method in which a single <em>unit</em> of source code,
for example, a single function is tested in isolation.
Unit tests are short code fragments, typically created by programmers
as part of the development process.
In a process like <a class="reference internal" href="#term-test-driven-development"><span class="xref std std-term">test-driven development</span></a> the unit tests
are written before any other code.</p>
</dd>
<dt id="term-unsorted-list">unsorted list</dt><dd><p>A <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> where the records stored in the list can appear
in any order (as opposed to a sorted list).
An unsorted list can support efficient (<span class="math notranslate nohighlight">\(\Theta(1)\)</span>)
insertion time (since you can put the record anywhere
convenient), but requires <span class="math notranslate nohighlight">\(\Theta(n)\)</span> time for both search
and deletion.</p>
</dd>
<dt id="term-unvisited">unvisited</dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> algorithms, this refers to a node that has not
been processed at the current point in the algorithm.</p>
</dd>
<dt id="term-upper-bound">upper bound</dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> that is
always greater than or equal to the growth rate of the
<a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> in question.
In practice, this is the slowest-growing function that we know
grows at least as fast as all but a constant number of inputs.
It could be a gross over-estimate of the truth.
Since the upper bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> or
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>), we typically have to specify which
situation we are referring to.</p>
</dd>
<dt id="term-variable-length-coding">variable-length coding</dt><dd><p>Given a collection of objects, a variable-length coding scheme
assigns a code to each object in the collection using codes that
can be of different lengths.
Typically this is done in a way such that the objects that are
most likely to be used have the shortest codes, with the goal of
minimizing the total space needed to represent a sequence of
objects, such as when representing the characters in a document.
This is in contrast to <a class="reference internal" href="#term-fixed-length-coding"><span class="xref std std-term">fixed-length coding</span></a>.</p>
</dd>
<dt id="term-vector">vector</dt><dd><p>In set notation, another term for a <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.
As a data structure, the term vector usually used as a synonym
for a <a class="reference internal" href="#term-dynamic-array"><span class="xref std std-term">dynamic array</span></a>.</p>
</dd>
<dt id="term-vertex">vertex</dt><dd><p>Another name for a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> in a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.</p>
</dd>
<dt id="term-visit">visit</dt><dd><p>During the process of a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> on a <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> or
<a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> the action that takes place on each <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a>.</p>
</dd>
<dt id="term-visitor">visitor</dt><dd><p>A <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> where a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> process is
given a function (known as the visitor) that is applied to every
object in the collection being traversed.
For example, a generic tree or graph traversal might be
designed such that it takes a function parameter,
where that function is applied to each node.</p>
</dd>
<dt id="term-volatile">volatile</dt><dd><p>In the context of computer memory, this refers to a memory that
loses all stored information when the power is turned off.</p>
</dd>
<dt id="term-worst-case">worst case</dt><dd><p>In algorithm analysis, the <a class="reference internal" href="#term-problem-instance"><span class="xref std std-term">problem instance</span></a> from among
all problem instances for a given input size <span class="math notranslate nohighlight">\(n\)</span> that has
the greatest cost. Note that the worst case is <strong>not</strong> when
<span class="math notranslate nohighlight">\(n\)</span> is big, since we are referring to the worst from a
class of inputs (i.e, we want the worst of those inputs of size
<span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd>
</dl>
</div>


  <div id=scprogresscontainer>
    You have attempted <span id=scprogresstotal></span> of <span id=scprogressposs></span> activities on this page <div id="subchapterprogress"></div>
  </div>
  
      
<ul>
  <li id="relations-prev" style="opacity:0.4" onmouseover="mouseOverPrev()" onmouseout="mouseOutPrev()"class="navLink" title='Previous Section - 17.4. std::copy and Iterator Adapters' data-toggle="tooltip">
    <a href="algorithms/copy.html" aria-label="17.4. std::copy and Iterator Adapters">
        <div style="background-color: white; border-style:solid; border-color:lightgrey; border-width:2px; width:100px; height:50px">
            <i class='prevNav glyphicon glyphicon-chevron-left'  style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black;"></i>
        </div>
    </a>
  </li>
</ul>

  
<ul>
  <li id="relations-next" style="opacity:0.4" onmouseover="mouseOverNext()" onmouseout="mouseOutNext()" class="navLink" title='Next Section - Appendix A - Development Environment' data-toggle="tooltip" >
    <a href="back-matter/app-a/index.html" aria-label="Appendix A - Development Environment">
      <div style="background-color: white; border-style:solid; border-color:lightgrey; border-width:2px; width:100px; height:50px">
          <i id="relationsNextIcon" class='nextNav glyphicon glyphicon-chevron-right' style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black; "></i>
      </div>
    </a>
  </li>
</ul>

<script type="text/javascript">

  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});

</script>

<script>
	function mouseOverPrev() {
		document.getElementById("relations-prev").style.opacity=1;
	}

	function mouseOutPrev() {
		document.getElementById("relations-prev").style.opacity=0.4;
	}
	function mouseOverNext() {
		document.getElementById("relations-next").style.opacity=1;
	}

	function mouseOutNext() {
		document.getElementById("relations-next").style.opacity=0.4;
	}
</script>
  
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2020 Dave Parillo.
      Created using <a href="http://runestoneinteractive.org/">Runestone</a> 5.5.5.
    </p>
  </div>
</footer>




<script> getSwitch(); </script>


  </body>
</html>