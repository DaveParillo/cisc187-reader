<!-- ****************************************
     |docname| - main template for this theme
     **************************************** -->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>15.6. Closed hashing &#8212; CISC 187 Course Reader Overview</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/accessibility.css?v=50109A2C" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css?v=58BC228F" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/637.0fa6cababf056764.css?v=F9484CEF" />
    <link rel="stylesheet" type="text/css" href="../_static/runestone.3eb60bc006ae9a54.css?v=3A5A250C" />



    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/animationbase.js?v=A043C3A7"></script>
    <script src="../_static/matrixeq.js?v=D64CFA5A"></script>
    <script src="../_static/runtime.66b619f51b746382.bundle.js?v=C3F69EE5"></script>
    <script src="../_static/637.d54be67956c5c660.bundle.js?v=915B1670"></script>
    <script src="../_static/runestone.ecc6dff5cad8b815.bundle.js?v=AE959292"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="15.7. Analysis of hash tables" href="hash_table_analysis.html" />
    <link rel="prev" title="15.5. Analysis of separate chaining" href="separate_chaining_analysis.html" />


<link rel="shortcut icon" href="/cisc187-reader/static/favicon.ico" type="image/ico" />



<link rel="canonical" href="https://{{canonical_host}}{{new_server_prefix}}/books/published/{{base_course}}/{{pagepath}}" />


<script>
  eBookConfig = {};
  
    eBookConfig.useRunestoneServices = false;
    eBookConfig.host = 'https://daveparillo.github.io/cisc187-reader/' || 'http://127.0.0.1:8000';
    eBookConfig.app = eBookConfig.host+'/cisc187-reader';
    eBookConfig.course = 'cisc187-reader';
    eBookConfig.basecourse = 'cisc187-reader';
    eBookConfig.isLoggedIn = false;
    eBookConfig.enableCompareMe = eBookConfig.useRunestoneServices;
    eBookConfig.new_server_prefix = '';
  
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.python3 = true;
  eBookConfig.acDefaultLanguage = 'cpp' ? 'cpp' : 'python'
  eBookConfig.runestone_version = '6.6.2';
  eBookConfig.jobehost = 'https://delicate-frost-8843.fly.dev';
  eBookConfig.proxyuri_runs = '/jobe/index.php/restapi/runs/';
  eBookConfig.proxyuri_files = '/jobe/index.php/restapi/files/';
  eBookConfig.enable_chatcodes = false ? false : false;
  eBookConfig.enableScratchAC = true;

</script>

<!-- Ad Serving Headers Only serve ads to Anonymous Users -->



  </head><body>


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse" aria-label="navbar toggle">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        
        
          <div class="brand-logo"><img src="../_static/img/RAIcon.png" alt=""></div>
        
        <a class="navbar-brand" href="../index.html" aria-label="index-page">
          
          cisc187-reader
        </a>
      </div>
    </div>



    <div class="navbar-collapse collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right" >

        <li class="divider-vertical"></li>

        <!-- social media dropdown -->
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>
        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'><span class="visuallyhidden" aria-label="Search">Search</span></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='../index.html' aria-label="index-page">Table of Contents</a></li>
            
            <li><a href='../genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="../search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>
        <!-- <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li> -->

        <!-- <li class="dropdown">             -->
          <li id="scratch_ac_link" class="dropdown"><a href="javascript:runestoneComponents.popupScratchAC()">
              <i class="glyphicon glyphicon-pencil" style="opacity:0.9;"><span class="visuallyhidden" aria-label="Scratch Activecode" >Scratch Activecode</span></i></a></li>
        <!-- </li> -->

        <li class="divider-vertical"></li>

        
      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        
          
          <li class="divider-vertical"></li>
        
        <!-- 
          
  <li id="relations-prev" title="Previous Chapter - <span class="section-number">15.5. </span>Analysis of separate chaining" data-toggle="tooltip">
    <a href="separate_chaining_analysis.html" >
      <i class='glyphicon glyphicon-backward' style='opacity:0.9;'></i>
    </a>
  </li>
  
  <li id="relations-next" title='Next Chapter - <span class="section-number">15.7. </span>Analysis of hash tables' data-toggle="tooltip" >              
    <a href="hash_table_analysis.html" >
        <i class='glyphicon glyphicon-forward' style='opacity:0.9;'></i>
    </a>
  </li>
  <li class="divider-vertical"></li>

<script>
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  window.addEventListener('load', (event) => {
    $('#relations-prev').tooltip(opts);
    $('#relations-next').tooltip(opts);
  });
</script>
        -->
        
          <li></li>
        
      </ul>
      </div> <!-- navbar-collapse -->
    </div> <!-- navbar -->
  </div> <!-- container -->


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content" role="main">

<!-- Ad Serving for Runestone Campaign -->


  
  <section id="closed-hashing">
<span id="index-0"></span><h1><span class="section-number">15.6. </span>Closed hashing<a class="headerlink" href="#closed-hashing" title="Permalink to this heading">Â¶</a></h1>
<p>In closed hashing, the hash array contains individual elements
rather than a collection of elements.
When a key we want to insert collides with a key already in the table,
we resolve the collision by searching for another open <a class="reference internal" href="../glossary.html#term-slot"><span class="xref std std-term">slot</span></a> within
the table where we can place the new key.</p>
<p>Each slot in the hash table contains a <code class="docutils literal notranslate"><span class="pre">hash_entry</span></code>, composed of
one data element and a status field indicating whether that slot is
<em>occupied</em>, <em>empty</em>, or <em>deleted</em>.</p>
<div id='hash_set_tab_group' data-component="tabbedStuff"  class='alert alert-warning '><div data-component="tab" data-tabname="hash_set" >
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">hash_status</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">OCCUPIED</span><span class="p">,</span><span class="w"> </span><span class="n">EMPTY</span><span class="p">,</span><span class="w"> </span><span class="n">DELETED</span><span class="w"> </span><span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hash_entry</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="n">hash_status</span><span class="w"> </span><span class="n">info</span><span class="p">;</span>

<span class="w">  </span><span class="n">hash_entry</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="n">info</span><span class="p">(</span><span class="n">hash_status</span><span class="o">::</span><span class="n">EMPTY</span><span class="p">)</span><span class="w">  </span><span class="p">{}</span>
<span class="w">  </span><span class="n">hash_entry</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">hash_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">{</span><span class="n">value</span><span class="p">}</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">hash_set</span></code> backing store is an array of <code class="docutils literal notranslate"><span class="pre">hash_entry</span></code>
objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Key</span><span class="p">,</span>
<span class="w">          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">,</span>
<span class="w">          </span><span class="k">class</span><span class="w"> </span><span class="nc">Comparator</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">hash_set</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Key</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">key_type</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">Key</span><span class="p">;</span>

<span class="w">    </span><span class="n">hash_set</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">array</span><span class="o">&lt;</span><span class="n">hash_entry</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">table</span><span class="p">;</span>
<span class="w">    </span><span class="n">Comparator</span><span class="w"> </span><span class="n">compare</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Collisions are resolved by trying a series of locations,
<span class="math notranslate nohighlight">\(p_0, p_1, p_2, \ldots p_{N-1}\)</span>
until we find what we are looking for.
Each position is calculated as:</p>
<div class="math notranslate nohighlight">
\[pos_i = hash(value) + f(n)\]</div>
<p>where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hash(value)</span></code> is the <a class="reference internal" href="../glossary.html#term-home-slot"><span class="xref std std-term">home slot</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f()</span></code> is a function taking an integer
number of tries and returns an integer offset.</p></li>
</ul>
<p>How are new positions used in the hash table?</p>
<dl class="simple">
<dt>Searching:</dt><dd><p>Try positions <span class="math notranslate nohighlight">\(p_0, p_1, p_2, \ldots\)</span>
until we find the requested value or an <code class="docutils literal notranslate"><span class="pre">EMPTY</span></code> slot.</p>
</dd>
<dt>Inserting:</dt><dd><p>Try positions <span class="math notranslate nohighlight">\(p_0, p_1, p_2, \ldots\)</span>
until we find the same value, an <code class="docutils literal notranslate"><span class="pre">EMPTY</span></code> slot, or
a <code class="docutils literal notranslate"><span class="pre">DELETED</span></code> slot.
Put the new value in the position pound and
mark the position as <code class="docutils literal notranslate"><span class="pre">OCCUPIED</span></code>.</p>
</dd>
<dt>Erasing:</dt><dd><p>Try positions <span class="math notranslate nohighlight">\(p_0, p_1, p_2, \ldots\)</span>
until we find the requested value or an <code class="docutils literal notranslate"><span class="pre">EMPTY</span></code> slot.
If we find the value, then
mark the position as <code class="docutils literal notranslate"><span class="pre">DELETED</span></code>.</p>
</dd>
</dl>
</div><div data-component="tab" data-tabname="find" >
<p>Find takes a value of the <code class="docutils literal notranslate"><span class="pre">hash_entry</span></code> key type as a parameter
and returns the position of the value in the table.
It returns <code class="docutils literal notranslate"><span class="pre">N</span></code> if the value is not in the table.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="nf">find</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="hll"><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">DELETED</span><span class="w"> </span><span class="o">||</span>
</span><span class="hll"><span class="w">         </span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">OCCUPIED</span>
</span><span class="hll"><span class="w">         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">compare</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">))))</span>
</span><span class="hll"><span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">next_slot</span><span class="p">(</span><span class="n">count</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">EMPTY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The loop condition is fairly complicated and needs discussion.
There are three ways to exit this loop:</p>
<ul class="simple">
<li><p>We hit an <code class="docutils literal notranslate"><span class="pre">EMPTY</span></code> space (not <code class="docutils literal notranslate"><span class="pre">DELETED</span></code>, and not <code class="docutils literal notranslate"><span class="pre">OCCUPIED</span></code>)</p></li>
<li><p>We hit an <code class="docutils literal notranslate"><span class="pre">OCCUPIED</span></code> space that has the value we want</p></li>
<li><p>We have tried <code class="docutils literal notranslate"><span class="pre">N</span></code> different positions. (No place left to look!)</p></li>
</ul>
</div><div data-component="tab" data-tabname="contains" >
<p>With <code class="docutils literal notranslate"><span class="pre">find</span></code> in place, other search operations are easy.
Simply call find and evaluate the results.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">contains</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w">  </span><span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">count</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w">  </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that since our set is still forcing a uniqueness constraint,
<code class="docutils literal notranslate"><span class="pre">count</span></code> will return only <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div><div data-component="tab" data-tabname="erase" >
<p>The code to remove elements is just as simple.
Easier than the <code class="docutils literal notranslate"><span class="pre">erase</span></code> we implemented for open hashing.</p>
<p>We try to find that element.</p>
<ul class="simple">
<li><p>If found, we mark that slot <code class="docutils literal notranslate"><span class="pre">DELETED</span></code> and decrement the size.</p></li>
<li><p>Otherwise, do nothing.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">erase</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">DELETED</span><span class="p">;</span>
<span class="w">    </span><span class="o">--</span><span class="n">sz</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div data-component="tab" data-tabname="insert" >
<p>Inserts are a bit more work, because they involve potentially
looking for an open slot to store a value.</p>
<p>Because this is a set (and not a multiset) we first call <code class="docutils literal notranslate"><span class="pre">find</span></code>
to see if the value is already there.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">OCCUPIED</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">      </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">next_slot</span><span class="p">(</span><span class="n">count</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// could not add, table is full</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">OCCUPIED</span><span class="p">;</span>
<span class="w">    </span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="o">++</span><span class="n">sz</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// else replace existing value</span>
<span class="w">  </span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If not found (<code class="docutils literal notranslate"><span class="pre">pos</span> <span class="pre">==</span> <span class="pre">N</span></code>), then we need to find a slot.
The loop that does this is similar the <code class="docutils literal notranslate"><span class="pre">find</span></code> loop,
but unlike <code class="docutils literal notranslate"><span class="pre">find</span></code>, we stop at the first <code class="docutils literal notranslate"><span class="pre">DELETED</span></code> or <code class="docutils literal notranslate"><span class="pre">EMPTY</span></code> slot.</p>
<p>In the other searches, we had kept going past <code class="docutils literal notranslate"><span class="pre">DELETED</span></code> slots,
because the element we wanted might have been stored
after an element that was later erased.
But now we are only looking for an unoccupied slot to put something,
so either a slot that has never been occupied (<code class="docutils literal notranslate"><span class="pre">EMPTY</span></code>) or
a slot that used to be occupied but is no longer (<code class="docutils literal notranslate"><span class="pre">DELETED</span></code>) works.</p>
</div><div data-component="tab" data-tabname="Run it" >
<p>The example contains <code class="docutils literal notranslate"><span class="pre">#define</span></code> statements you can use to change
how the next slot is found.</p>
<p>Try it with different hash table sizes to see how clumping changes
with the different probing strategies.</p>

<div class="runestone explainer ac_section ">
<div data-component="activecode" id=hash_table_closed_ac data-question_label="15.6.1">
<div id=hash_table_closed_ac_question class="ac_question">

</div>
<textarea data-lang="cpp" id="hash_table_closed_ac_editor" 
      data-timelimit=25000     
    data-audio=''      
    data-compileargs="[&#x27;-Wall&#x27;, &#x27;-Wextra&#x27;, &#x27;-pedantic&#x27;, &#x27;-std=c++11&#x27;]"       data-wasm=/_static
     style="visibility: hidden;">
#include <array>
#include <cstddef>
#include <iomanip>
#include <iostream>
#include <utility>

using std::array;

#define USE_LINEAR_PROBING

#if defined(USE_QUADRATIC_PROBING)
    // find next slot using quadratic probing
    constexpr
      size_t next_slot(size_t count) noexcept { return count*count; }

#elif defined(USE_DOUBLE_HASHING)

    // find next slot using double hashing
    constexpr
      size_t next_slot(size_t count) noexcept { return count * std::hash<size_t>()(count); }
#else   // default to USE_LINEAR_PROBING
    // find next slot using linear probing
    constexpr
      size_t next_slot(size_t count) noexcept { return count; }

#endif


enum class hash_status { OCCUPIED, EMPTY, DELETED };

template <class T>
struct hash_entry
{
  T data;
  hash_status info;

  hash_entry(): info(hash_status::EMPTY)  {}
  hash_entry(const T& value, hash_status status)
    : data{value}
    , info(status)
    {}
};

template <class T>
std::ostream& operator<<(std::ostream& os, const hash_entry<T>& rhs)
{
  if (rhs.info == hash_status::OCCUPIED) {
    os << rhs.data;
  } else if (rhs.info == hash_status::EMPTY) {
    os << 'E';
  } else {
    os << 'D';
  }
  return os;
}

template <class Key,
         size_t N,
         class Comparator=std::equal_to<Key>>
class hash_set
{
  public:
    using value_type = Key;
    using key_type   = Key;

    hash_set() = default;

    size_t find (const Key& value) const
    {
      size_t hash = std::hash<Key>()(value);
      size_t pos = hash % N;
      size_t count = 0;
      while ((table[pos].info == hash_status::DELETED ||
             (table[pos].info == hash_status::OCCUPIED
             && (!compare(table[pos].data, value))))
          && count < N)
      {
        ++count;
        pos = (hash + next_slot(count)) % N;
      }
      if (count >= N || table[pos].info == hash_status::EMPTY) {
        return N;
      }
      return pos;
    }

    constexpr
      bool contains (const Key& value) const noexcept
    {
      return  find(value) != N;
    }

    int count (const Key& value)
    {
      unsigned pos = find(value);
      return  (pos == N) ? 0 : 1;
    }

    void erase (const Key& value)
    {
      unsigned pos = find(value);
      if (pos != N) {
        table[pos].info = hash_status::DELETED;
        --sz;
      }
    }


    bool insert (const Key& value)
    {
      size_t hash = std::hash<Key>()(value);
      unsigned pos = find(value);
      if (pos == N) {
        size_t count = 0;
        pos = hash % N;
        while (table[pos].info == hash_status::OCCUPIED && count < N)
        {
          ++count;
          pos = (hash + next_slot(count)) % N;
        }
        if (count >= N) {
          return false;  // could not add, table is full
        }
        table[pos].info = hash_status::OCCUPIED;
        table[pos].data = value;
        ++sz;
        return true;
      }
      // else replace existing value
      table[pos].data = value;
      return true;
    }


    constexpr
      size_t size() const noexcept { return sz; }

    constexpr
      bool empty() const noexcept { return sz == 0; }

  private:
    array<hash_entry<Key>, N> table;
    Comparator compare;
    size_t sz = 0;

    friend
      std::ostream& operator<<(std::ostream& os, const hash_set& rhs)
      {
        os << '[';
        for (const auto& slot: rhs.table) {
          os << slot << ',';
        }
        return os << ']';
      }

};

int main() {
  using std::cout;
  using std::endl;
  auto foo = hash_set<int, 11>{};
  cout << "sz: " << foo.size() << endl;
  cout << std::boolalpha << "mt?: " << foo.empty() << endl;
  cout << foo << endl;
  foo.insert(72);
  foo.insert(72);
  cout << "insert two 72's count:"<< endl;
  cout << foo.count(72) << endl;
  cout << foo << endl;
  cout << "mt?: " << foo.empty() << endl;

  foo.erase(72);
  cout << "count after erase:"<< endl;
  cout << foo.count(72) << endl;

  foo.insert(-1);
  foo.insert(0);
  foo.insert(1);
  foo.insert(2);
  foo.insert(9);
  foo.insert(81);
  foo.insert(121);
  foo.insert(572);
  foo.insert(999);
  cout << foo << endl;
  foo.erase(-1);
  cout << foo << endl;
}
</textarea>
</div>
</div>
</div>
    </div>

<section id="choosing-the-next-slot">
<span id="index-1"></span><h2><span class="section-number">15.6.1. </span>Choosing the next slot<a class="headerlink" href="#choosing-the-next-slot" title="Permalink to this heading">Â¶</a></h2>
<p>The function <code class="docutils literal notranslate"><span class="pre">next_slot(n)</span></code> in the <code class="docutils literal notranslate"><span class="pre">find</span></code> and <code class="docutils literal notranslate"><span class="pre">insert</span></code> functions
controls the sequence of positions that will be checked.
It is the implementation of the function <span class="math notranslate nohighlight">\(f(n)\)</span> mentioned earlier.
Recall the find function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="nf">find</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">DELETED</span><span class="w"> </span><span class="o">||</span>
<span class="w">         </span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">OCCUPIED</span>
<span class="w">         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">compare</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">))))</span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="hll"><span class="w">    </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">next_slot</span><span class="p">(</span><span class="n">count</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
</span><span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash_status</span><span class="o">::</span><span class="n">EMPTY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On our <span class="math notranslate nohighlight">\(n_{th}\)</span> try, we examine the position</p>
<div class="math notranslate nohighlight">
\[pos_n = hash(value) + f(n)\]</div>
<p>where <span class="math notranslate nohighlight">\(hash(value)\)</span> always returns the <a class="reference internal" href="../glossary.html#term-home-slot"><span class="xref std std-term">home slot</span></a> for any
hashed value.
This is the location that the value would be stored if currently unoccupied.
The <code class="docutils literal notranslate"><span class="pre">f</span></code> function computes an offset from the reference location.
The most common schemes for choosing the next slot are
<a class="reference internal" href="../glossary.html#term-linear-probing"><span class="xref std std-term">linear probing</span></a>,
<a class="reference internal" href="../glossary.html#term-quadratic-probing"><span class="xref std std-term">quadratic probing</span></a>, and
<a class="reference internal" href="../glossary.html#term-double-hashing"><span class="xref std std-term">double hashing</span></a>.</p>
<dl>
<dt>Linear probing</dt><dd><div class="math notranslate nohighlight">
\[f(n) = n\]</div>
<p>If a collision occurs at location <code class="docutils literal notranslate"><span class="pre">pos</span></code>,
we next check locations
<span class="math notranslate nohighlight">\(pos+1 \pmod N, pos+2 \pmod N, pos+3 \pmod N, \ldots\)</span> and so on.</p>
<p>Because collisions get stored in a location originally intended for
another hash code, values have a tendency to clump together in the
hash table.</p>
</dd>
<dt>Quadratic probing</dt><dd><div class="math notranslate nohighlight">
\[f(n) = n^2\]</div>
<p>If a collision occurs at location <code class="docutils literal notranslate"><span class="pre">pos</span></code>,
we next check locations
<span class="math notranslate nohighlight">\(pos+1 \pmod N, pos+4 \pmod N, pos+9 \pmod N, \ldots\)</span> and so on.</p>
<p>Because the jumps between slots increases as the number of tries increases,
this function tends to reduce clumping (and results in shorter searches).
<em>``But``</em> it is not guaranteed to find an available empty slot if the table is
more than half full or if <code class="docutils literal notranslate"><span class="pre">N</span></code> is not a prime number.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Again, prime numbers!</p>
<p>Remember the earlier discussion about how <span class="math notranslate nohighlight">\(% N\)</span> tends to improve the
key distribution when <code class="docutils literal notranslate"><span class="pre">N</span></code> is prime?
You can see why itâs part of programming âfolkloreâ that hash tables
should be prime-number sized, even if most programmers canât say
<em>why</em> thatâs supposed to be good.</p>
</div>
</dd>
<dt>Double hashing</dt><dd><div class="math notranslate nohighlight">
\[f(n) = n * h_2(value)\]</div>
<p>where <span class="math notranslate nohighlight">\(h_2\)</span> is an alternate hash code function.</p>
<p>If a collision occurs at location <code class="docutils literal notranslate"><span class="pre">pos</span></code>,
we next check locations
<span class="math notranslate nohighlight">\((pos+1*h_2(value)) \pmod N, pos+2*h_2(value)) \pmod N, pos+3*h_2(value)) \pmod N, \ldots\)</span> and so on.</p>
<p>This also tends to reduce clumping, but, as with quadratic hashing,
it is possible to get unlucky and miss open slots when trying to find
a place to insert a new key.</p>
</dd>
</dl>
</section>
<section id="analysis-of-closed-hashing">
<h2><span class="section-number">15.6.2. </span>Analysis of closed hashing<a class="headerlink" href="#analysis-of-closed-hashing" title="Permalink to this heading">Â¶</a></h2>
<p>We define <span class="math notranslate nohighlight">\(\lambda\)</span>, the <a class="reference internal" href="../glossary.html#term-load-factor"><span class="xref std std-term">load factor</span></a> of a hash table,
as the number of items contained in the table divided by the table size.
In other words, the load factor measures what fraction of the table is full.
By definition, <span class="math notranslate nohighlight">\(0 \le \lambda \le 1\)</span>.</p>
<ul class="simple">
<li><p>Given an ideal collision strategy,
the probability of an arbitrary cell being full is <span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>Therefore,
the probability of an arbitrary cell being empty is <span class="math notranslate nohighlight">\(1 - \lambda\)</span>.</p></li>
<li><p>The average number of table elements we expect to examine before finding
an open position is therefore <span class="math notranslate nohighlight">\(\frac {1}{1-\lambda}\)</span>.</p></li>
</ul>
<p>Since we never look at more than <code class="docutils literal notranslate"><span class="pre">N</span></code> positions,
given an ideal collision strategy, finds and inserts are on average</p>
<div class="math notranslate nohighlight">
\[O \left ( min \left ( \frac {1}{1-\lambda}, N \right ) \right )\]</div>
<p>The graph shows how <span class="math notranslate nohighlight">\(\frac {1}{1-\lambda}\)</span> changes as
<span class="math notranslate nohighlight">\(\lambda\)</span> increases.</p>
<figure class="align-default">
<img alt="../_images/closed_hashing-1.png" class="plot-directive" src="../_images/closed_hashing-1.png" />
</figure>
<p>If the table is less than half full (<span class="math notranslate nohighlight">\(\lambda \lt 0.5\)</span>)
then we expect to try <strong>on average</strong> no more than 2 slots
during a search or insert.
Not too bad.
But as <span class="math notranslate nohighlight">\(\lambda\)</span> gets larger,
the average number of slots examined grows toward <code class="docutils literal notranslate"><span class="pre">N</span></code>.
As the table fills and <code class="docutils literal notranslate"><span class="pre">sz</span></code> approaches <code class="docutils literal notranslate"><span class="pre">N</span></code>, the performance
degenerates toward <span class="math notranslate nohighlight">\(O(N)\)</span> behavior.</p>
<p>Because of this, a general rule of thumb for hash tables is
to keep them no more than half full.
At that load factor, we can treat searches and inserts as <span class="math notranslate nohighlight">\(O(1)\)</span>
operations.
If we let the load factor get much higher, we start seeing <span class="math notranslate nohighlight">\(O(N)\)</span>
performance.</p>
<p>No collision resolution scheme is truly ideal,
so keeping the load factor low enough is even more important in practice
than this idealized analysis indicates.</p>
<hr class="docutils" />
<div class="admonition-more-to-explore admonition">
<p class="admonition-title">More to Explore</p>
<ul class="simple">
<li><p>The content on this page was adapted from
<a class="reference external" href="https://www.cs.odu.edu/~zeil/cs361/f16/Public/collisions/index.html">Resolving Collisions</a>,
by Steven J. Zeil for his data structures course CS361.</p></li>
</ul>
</div>
</section>
</section>


  

  <div id="scprogresscontainer">
    You have attempted <span id="scprogresstotal"></span> of <span id="scprogressposs"></span> activities on this page <div id="subchapterprogress" aria-label="Page progress"></div>
  </div>

  <ul role="navigation" class="nextprev-list nextprev-list" aria-label="Change page">
<li id="relations-prev" class="navLink" title='Previous Section - 15.5. Analysis of separate chaining' data-toggle="tooltip">
  <a href="separate_chaining_analysis.html" aria-label="Previous - 15.5. Analysis of separate chaining">
    <i class='prevNav glyphicon glyphicon-chevron-left'  style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black;"></i>
  </a>
</li>

  <li id="relations-next" class="navLink" title='Next Section - 15.7. Analysis of hash tables' data-toggle="tooltip" >
    <a href="hash_table_analysis.html" aria-label="Next - 15.7. Analysis of hash tables">
      <i id="relationsNextIcon" class='nextNav glyphicon glyphicon-chevron-right' style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black; "></i>
    </a>
  </li>
</ul>

<script>
window.addEventListener('load', (event) => {
  $('#relations-prev').tooltip({'placement': 'right', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement': 'left', 'delay': { show: 100, hide: 50}});
});
</script>

</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2024 Dave Parillo.
      Created using <a href="http://runestoneinteractive.org/">Runestone</a> 6.6.2.
    </p>
  </div>
</footer>




<script>
  window.addEventListener('load', (event) => {
    runestoneComponents.getSwitch();
  });
</script>


  </body>
</html>