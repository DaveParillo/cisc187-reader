<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>14.3. Binary Search Tree iterators &#8212; CISC 187 Course Reader Overview</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css?v=58BC228F" />
    <link rel="stylesheet" type="text/css" href="../_static/CodeChat.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/handsontable@7.2.2/dist/handsontable.full.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css?v=B36B48D" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css?v=910DF1E1" />
    <link rel="stylesheet" type="text/css" href="../_static/accessibility.css?v=50109A2C" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-3.4.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/presenter_mode.css?v=9FF1320F" />
    <link rel="stylesheet" type="text/css" href="../_static/jquery-ui-1.10.3.custom.min.css?v=97E0178A" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/user-highlights.css?v=A2326E52" />
    <link rel="stylesheet" type="text/css" href="../_static/runestone-custom-sphinx-bootstrap.css?v=5.5.5" />
    <link rel="stylesheet" type="text/css" href="../_static/theme-overrides.css?v=2DAFE138" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/pytutor-embed.bundle.js?v=268B5C04"></script>
    <script src="../_static/matrixeq.js?v=D64CFA5A"></script>
    <script src="../_static/animationbase.js?v=A043C3A7"></script>
    <script src="../_static/html4css1.css?v=4533ACD3"></script>
    <script src="../_static/jquery.highlight.js?v=F1C496C8"></script>
    <script src="../_static/sql-wasm.js?v=D71B5933"></script>
    <script src="https://cdn.jsdelivr.net/npm/handsontable@7.2.2/dist/handsontable.full.js"></script>
    <script src="../_static/webglinteractive.js?v=2B768384"></script>
    <script src="../_static/FileSaver.min.js?v=8408C997"></script>
    <script src="../_static/Blob.js?v=AEC2447"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.emitter.bidi.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.emitter.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.fallbacks.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.messagestore.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.parser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.i18n/1.0.5/jquery.i18n.language.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega@4.0.0-rc.2/build/vega.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@2.5.0/build/vega-lite.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@3.14.0/build/vega-embed.js"></script>
    <script src="../_static/runestone.js?v=92D8BBF0"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js?v=2B07FE4F"></script>
    <script src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
    <script src="../_static/jquery-fix.js?v=1226591B"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/jquery.idle-timer.js?v=E942DAF1"></script>
    <script src="../_static/presenter_mode.js?v=2DF16FB4"></script>
    <script src="../_static/theme.js?v=D899FB97"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="14.5. The set class" href="set.html" />
    <link rel="prev" title="14.2. Binary Search Trees" href="bst.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<link rel="shortcut icon" href="/cisc187-reader/static/favicon.ico" type="image/ico" />

<script type="text/javascript">
  eBookConfig = {};
  
    eBookConfig.useRunestoneServices = false;
    eBookConfig.host = 'https://daveparillo.github.io/cisc187-reader/' || 'http://127.0.0.1:8000';
    eBookConfig.app = eBookConfig.host+'/cisc187-reader';
    eBookConfig.course = 'cisc187-reader';
    eBookConfig.basecourse = 'cisc187-reader';
    eBookConfig.isLoggedIn = false;
  
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.python3 = true;
  eBookConfig.acDefaultLanguage = 'cpp' ? 'cpp' : 'python'
  eBookConfig.runestone_version = '5.5.5';
  eBookConfig.jobehost = 'https://fierce-ridge-58946.herokuapp.com/http://jobe2.cosc.canterbury.ac.nz';
  eBookConfig.proxyuri_runs = '/jobe/index.php/restapi/runs/';
  eBookConfig.proxyuri_files = '/jobe/index.php/restapi/files/';
  eBookConfig.enable_chatcodes = false ? false : false;


</script>

<!-- Ad Serving Headers Only serve ads to Anonymous Users -->





  </head><body>


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="icon-bar" aria-label="navbar toggle" class="visuallyhidden">toggle navbar</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        
          <a class="brand-logo" style='background: transparent url("../_static/img/logo_small.png") no-repeat 0px 0px;'>&nbsp;<span aria-label="logo" class="visuallyhidden">Runestone Logo</span> </a>
        
        <a class="navbar-brand" href="../index.html" aria-label="index-page">
          
          cisc187-reader
        </a>
      </div>
    </div>



    <div class="navbar-collapse collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right" >

        <li class="divider-vertical"></li>


        <!-- social media dropdown -->
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>

        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'><span aria-label="Search" class="visuallyhidden">Search</span></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='../index.html' aria-label="index-page">Table of Contents</a></li>
            
            <li><a href='../genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="../search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>
        <!-- <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li> -->

        <!-- <li class="dropdown">             -->
          <li id="scratch_ac_link" class="dropdown"><a href="javascript:ACFactory.toggleScratchActivecode()">
              <i class="glyphicon glyphicon-pencil" style="opacity:0.9;"><span aria-label="Scratch Activecode" class="visuallyhidden">Scratch Activecode</span></i></a></li>
        <!-- </li> -->

        <li class="divider-vertical"></li>

        
      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        
          
          <li class="divider-vertical"></li>
        
        <!-- 
          
  <li id="relations-prev" title="Previous Chapter - <span class="section-number">14.2. </span>Binary Search Trees" data-toggle="tooltip">
    <a href="bst.html" >
      <i class='glyphicon glyphicon-backward' style='opacity:0.9;'></i>
    </a>
  </li>
  
  <li id="relations-next" title='Next Chapter - <span class="section-number">14.5. </span>The set class' data-toggle="tooltip" >              
    <a href="set.html" >
        <i class='glyphicon glyphicon-forward' style='opacity:0.9;'></i>
    </a>
  </li>
  <li class="divider-vertical"></li>

<script type="text/javascript">
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  $('#relations-prev').tooltip(opts);
  $('#relations-next').tooltip(opts);
</script>
        -->
        
          <li></li>
        
      </ul>

      </div> <!-- navbar -->







    </div> <!-- container -->
  </div>
</div>


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content" role="main">
<!-- Ad Serving for Runestone Campaign -->


  
  <div class="section" id="binary-search-tree-iterators">
<span id="index-0"></span><h1><span class="section-number">14.3. </span>Binary Search Tree iterators<a class="headerlink" href="#binary-search-tree-iterators" title="Permalink to this headline">¶</a></h1>
<p>The recursive traversal algorithms work well for implementing
tree-based ADT member functions,
but if we are trying to hide the trees inside some ADT
for example, using binary search trees to implement std::set
or using STL algorithms or range-for loops,
then we need to provide iterators for walking though the contents of the tree.</p>
<p>Iterators for tree-based data structures can be more complicated than those
for linear structures.</p>
<p>For arrays (and vectors and deques and other array-like structures)
and linked lists, a single pointer can implement an iterator.</p>
<p>Given the current position, it is easy to move forward to the next element.</p>
<p>For anything but a singly-linked list, we can also easily move backwards.</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-baed3b231c062b74484fc6c00c01f2ef358038eb.png" alt="a binary search tree" class="graphviz" /></div>
</div>
<p>But look at this binary search tree,
and suppose that you were implementing tree iterators as a single pointer.
Let’s see if we can “think” our way through the process of traversing this tree
one step at a time,
without needing to keep a whole stack of unfinished recursive calls around.</p>
<p>We’re going to try to visit the nodes in the same order we would process them
during an “in-order” traversal.
For a BST, in-order traversal means that we will visit the data in ascending order.</p>
<p>It’s not immediately obvious what our data structure for storing the
“current position” (i.e., an iterator) will be.
We might suspect that a pointer to a tree node will be part of
that data structure, because that worked with iterators over linked lists.</p>
<div class="section" id="bst-iterator-begin-and-end">
<span id="index-1"></span><h2><span class="section-number">14.3.1. </span>BST iterator <code class="docutils literal notranslate"><span class="pre">begin()</span></code> and <code class="docutils literal notranslate"><span class="pre">end()</span></code><a class="headerlink" href="#bst-iterator-begin-and-end" title="Permalink to this headline">¶</a></h2>
<p>As in any data structure, <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> refer to the
first element in the data structure and one past the last element.
In the last section, we said that
a BST is sorted when a level order traversal is used.</p>
<p>So what algorithm should we use to find the beginning?</p>

    <div data-component="reveal" id="reveal_bst_it_1"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>Start from the root and working our way down,
always taking left children, until we come to a node with no left child.</p>
<p>The left-most child of a BST is always the minimum element.</p>

    </div>
    <p>So what algorithm should we use to find the end?</p>

    <div data-component="reveal" id="reveal_bst_it_2"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>Just return the <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<p>It’s tempting to guess that you could do much the same as for <code class="docutils literal notranslate"><span class="pre">begin()</span></code>,
this time seeking out the right-most node.
But that would leave you pointing to the <strong>last</strong> node in the tree,
and <code class="docutils literal notranslate"><span class="pre">end()</span></code>, must always refer to the position after the last element
in the container.</p>

    </div>
    </div>
<div class="section" id="bst-iterator-operator">
<span id="index-2"></span><h2><span class="section-number">14.3.2. </span>BST iterator <code class="docutils literal notranslate"><span class="pre">operator++()</span></code><a class="headerlink" href="#bst-iterator-operator" title="Permalink to this headline">¶</a></h2>
<p>A quick review of the definition of iterators and the iterator design pattern.
We have a few facts to deal with:</p>
<ul class="simple">
<li><p>A tree is a <em>hierarchical</em> data structure</p></li>
<li><p>An <em>iterator</em> allows users to visit each element in a container
<em>sequentially</em> - with no awareness of the underlying structure.</p></li>
<li><p>In C++, iterators are implemented using pointer semantics.
The function <code class="docutils literal notranslate"><span class="pre">operator++()</span></code> is used to move to the next element.</p></li>
</ul>
<p>Given our familiar tree:</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-44fce24e4ddb85c3083de867c17ed382b6f6581f.png" alt="a binary search tree" class="graphviz" /></div>
</div>
<p>If we are iterating through our tree and are currently at the node
with value <code class="docutils literal notranslate"><span class="pre">40</span></code>, then how do we get to the next node?</p>

    <div data-component="reveal" id="reveal_bst_it_3"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>Well, we know that we should wind up at <code class="docutils literal notranslate"><span class="pre">50</span></code>.
But how can we get there?</p>
<p>We can’t, not with just a pointer to the node and
all the nodes pointing only to their children.</p>
<p>The only place you can go within this tree is down,
and there is no “down” from our current position.</p>

    </div>
    <p>In a binary tree, to get to the next node,
we need to know not only where we are,
but also how we got here.</p>
<p>One way is to do that is to implement the iterator as a
stack of pointers containing the path to the current node.
The stack would be used to simulate the activation stack during
a recursive traversal.</p>
<p>But this solution is clumsy and inefficient.
Iterators tend to get assigned (copied) a lot,
and we’d really like that to be a constant time - an O(1) operation.
Having to copy an entire stack of pointers just isn’t very attractive.</p>
<div class="section" id="bst-iterator-using-parent-pointers">
<h3><span class="section-number">14.3.2.1. </span>BST iterator using parent pointers<a class="headerlink" href="#bst-iterator-using-parent-pointers" title="Permalink to this headline">¶</a></h3>
<p>We can make the task of creating tree iterators much easier if we
redesign the tree nodes to add pointers from each node to its parent.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// a binary tree node</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">tree_node</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// link to parent simplifies iterators</span>
    <span class="n">tree_node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">T</span><span class="p">{},</span>
        <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
        <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
        <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">value</span><span class="p">{</span><span class="n">value</span><span class="p">}</span>
    <span class="p">,</span> <span class="n">left</span><span class="p">{</span><span class="n">left</span><span class="p">}</span>
    <span class="p">,</span> <span class="n">right</span><span class="p">{</span><span class="n">right</span><span class="p">}</span>
    <span class="p">,</span> <span class="n">parent</span><span class="p">{</span><span class="n">parent</span><span class="p">}</span>
    <span class="p">{</span> <span class="p">}</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>These nodes are then used to implement a tree class, which, as usual,
keeps track of the root of our tree in a data member.</p>
<p>The outline for a tree iterator is similar to what we have covered before:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">tree_iterator</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">difference_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">tree_iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">tree_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">n</span><span class="p">);</span>

    <span class="k">constexpr</span>
       <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">tree_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">tree_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">tree_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">tree_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>There is a subtlety when using our tree iterator in a BST.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
 <span class="k">class</span> <span class="nc">bstree</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
     <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
<span class="hll">     <span class="k">typedef</span> <span class="k">const</span> <span class="n">tree_iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
</span><span class="hll">     <span class="k">typedef</span> <span class="n">const_iterator</span> <span class="n">iterator</span><span class="p">;</span>
</span>     <span class="k">typedef</span> <span class="n">const_iterator</span> <span class="n">reverse_iterator</span><span class="p">;</span>
     <span class="k">typedef</span> <span class="n">const_iterator</span> <span class="n">const_reverse_iterator</span><span class="p">;</span>

     <span class="c1">// remainder omitted . . .</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>Note the type of all the iterators is <code class="docutils literal notranslate"><span class="pre">const</span></code>.
We only want <code class="docutils literal notranslate"><span class="pre">const</span></code> behavior for this ADT.
If we provided a “true” non-const iterator,
it would allow reassigning data in the tree:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">bstree</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myTree</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
</pre></div>
</div>
<p>which would very likely break the internal ordering of data,
violating the binary search tree property,
and making it useless for any future searches.
A <code class="docutils literal notranslate"><span class="pre">const</span></code> iterator allows us to look at data in the container,
but not change that data.</p>
</div>
</div>
<div class="section" id="implementing-bst-iterators">
<h2><span class="section-number">14.3.3. </span>Implementing BST iterators<a class="headerlink" href="#implementing-bst-iterators" title="Permalink to this headline">¶</a></h2>
<p>As discussed earlier, <code class="docutils literal notranslate"><span class="pre">begin()</span></code> is implemented by finding
the minimum element in the tree.</p>
<p>A free function that works with the <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> struct is enough:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">min_element</span><span class="p">(</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min_element</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bstree::begin()</span></code> can use this function directly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span>
  <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">const_iterator</span><span class="p">(</span><span class="n">min_element</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>And <code class="docutils literal notranslate"><span class="pre">end()</span></code> uses the null pointer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span>
  <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">const_iterator</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="section" id="implementing-operator">
<h3><span class="section-number">14.3.3.1. </span>Implementing <code class="docutils literal notranslate"><span class="pre">operator++()</span></code><a class="headerlink" href="#implementing-operator" title="Permalink to this headline">¶</a></h3>
<p>Before implementing <code class="docutils literal notranslate"><span class="pre">operator++</span></code>, let’s think about what is should do.
Given the following tree:</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-898f97d016a97320c87e9d076ff7d9f8aa5520d4.png" alt="a binary tree of letters" class="graphviz" /></div>
</div>
<p>(Not a binary search tree, just a tree).</p>
<p><strong>Question:</strong>
Suppose that we are currently at node E.
What is the in-order successor of E?
That is, the node that comes next during an in-order traversal of E?</p>

    <div data-component="reveal" id="reveal_bst_it_4"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>G is the in-order successor of E.</p>
<p>If you answered F, remember that in an in-order traversal,
we visit a node only after visiting all of its left descendents
and before visiting any of its right descendents.
Since we’re at E, we must have already visited F.</p>

    </div>
    <p>That example suggests that a node’s in-order successor tends to be among
its right descendants.</p>
<p>If our previous premise is correct, then what is the in-order successor to A?</p>

    <div data-component="reveal" id="reveal_bst_it_5"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>F is the in-order successor of A.</p>
<p>If we are at A during an in-order traversal,
then we have already visited all of A’s left descendents.
So the answer has to be C or one of its descendents.
It’s tempting to pick C because it’s only one step away from A.</p>
<p>But, remember, during an in-order traversal,
we visit a node only after visiting all of its left descendents and
before visiting any of its right descendents.</p>
<p>We have not yet visited C’s left descendants.
So have to run down from C to the left as far as we can go.</p>

    </div>
    <p>This suggests that, if a node has any right descendants, we should:</p>
<ul class="simple">
<li><p>Take a step down to the right, then</p></li>
<li><p>Run as far down to the left as we can.</p></li>
</ul>
<p>You can see how this would take us from A to F.
The same approach would take us from E to G as well.
So both of our prior examples are satisfied.</p>
<p>But that “step to the right, then run left” procedure raises a new question.
What happens if we are at a node with no right descendants?</p>
<p><strong>Question:</strong>
Suppose that we are currently at node C. What is the in-order successor of C?</p>

    <div data-component="reveal" id="reveal_bst_it_6"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>C does not <em>have</em> an in-order successor.
C is actually the final node in an in-order traversal.
After C is only <code class="docutils literal notranslate"><span class="pre">end()</span></code>.</p>

    </div>
    <p>While node C is an interesting special case,
it doesn’t make clear what should happen in the more general case
where we have no right child.</p>
<p><strong>Question:</strong> What is the in-order successor of F?</p>

    <div data-component="reveal" id="reveal_bst_it_7"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>E is the in-order successor of F.</p>
<p>So, when we have no right child, we may need to move back up in the tree.</p>

    </div>
    <p><strong>Question:</strong> What is the in-order successor of G?</p>

    <div data-component="reveal" id="reveal_bst_it_8"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>C is the in-order successor of G.</p>

    </div>
    <p>Why did we move up two steps in the tree this time,
when from F we only moved up one step?
The answer lies in whether we moved back up over a left-child edge or a right-child edge.</p>
<p>If we move up over a right-child edge,
we’re returning to a node that has already had all of its descendants,
left and right, visited.
So we must have already visited this node as well,
otherwise we would never have made it into its right descendants.</p>
<p>If we move up over a left-child edge,
then we’re returning to a node that has already had all of its
left descendants visited but none of its right descendants.
That’s the definition of when we want to visit a node during an
in-order traversal, so it’s time to visit this node.</p>
<p>So, if a node has no right child,
we move up in the tree (following the parent pointers)
until we move back over a left edge.
Then we stop.</p>
<p>When applying this procedure to C,
we move up to A (right edge),
then try to move up again to A’s parent.
But since A is the tree root,
it’s parent pointer will be null,
which is our signal that C has no in-order successor.</p>
<p>To summarize:</p>
<ul class="simple">
<li><p>If the current node has a non-null right child,</p>
<ul>
<li><p>Take a step down to the right</p></li>
<li><p>Then run down to the left as far as possible</p></li>
</ul>
</li>
<li><p>If the current node has a null right child,</p>
<ul>
<li><p>Move up the tree until we have moved over a left child link</p></li>
</ul>
</li>
</ul>
<div id='bst_it_operator' data-component="tabbedStuff"  class='alert alert-warning'><div data-component="tab" data-tabname="operator++" >
<p>Putting it all together.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tree_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// find the smallest node on the right subtree</span>
     <span class="n">node</span> <span class="o">=</span> <span class="n">mesa</span><span class="o">::</span><span class="n">tree</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="c1">// finished with right subtree and there is no right</span>
     <span class="c1">// search up for first parent with a non-null right child</span>
     <span class="c1">// or nullptr,</span>
     <span class="k">auto</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span> <span class="o">==</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
       <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
    </div>

</div>
</div>
</div>
<div class="section" id="using-parent-pointers">
<h1><span class="section-number">14.4. </span>Using parent pointers<a class="headerlink" href="#using-parent-pointers" title="Permalink to this headline">¶</a></h1>
<p>Using parent pointers does incur additional overhead.
We must store an additional pointer with every tree node.
It also means the functions used to manage the tree need to change.</p>
<p>Originally, inserting a node looked like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span>
 <span class="n">insert</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span>
         <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">node</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="c1">// add a new leaf</span>
   <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="c1">// else the value already exists in the tree</span>
   <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
   <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>But now when inserting a new node, we also need to maintain
correct parent relationships.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span>
  <span class="n">insert</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span>
          <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">node</span><span class="p">,</span>
          <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">parent</span><span class="p">)</span>
<span class="hll">  <span class="p">{</span>
</span>    <span class="c1">// add a new leaf</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="hll">      <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span>    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span>      <span class="k">return</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="hll">    <span class="p">}</span>
</span>    <span class="c1">// else the value already exists in the tree</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>When we make a new node, we need to pass the parent into
the <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> constructor.
Even though it won’t have children initially, it will have a parent.</p>
<p>When we make our recursive calls, the parent node passed in
is the current node.</p>
<hr class="docutils" />
<div class="admonition-more-to-explore admonition">
<p class="admonition-title">More to Explore</p>
<ul class="simple">
<li><p>The content on this page was adapted from
<a class="reference external" href="https://www.cs.odu.edu/~zeil/cs361/f16/Public/treetraversal/index.html">Binary Search Trees</a>,
by Steven J. Zeil for his data structures course CS361.</p></li>
<li><p><a class="reference external" href="http://btv.melezinek.cz">Binary tree visualizer</a></p></li>
</ul>
</div>
</div>


  <div id=scprogresscontainer>
    You have attempted <span id=scprogresstotal></span> of <span id=scprogressposs></span> activities on this page <div id="subchapterprogress"></div>
  </div>
  
      
<ul>
  <li id="relations-prev" style="opacity:0.4" onmouseover="mouseOverPrev()" onmouseout="mouseOutPrev()"class="navLink" title='Previous Section - 14.2. Binary Search Trees' data-toggle="tooltip">
    <a href="bst.html" aria-label="14.2. Binary Search Trees">
        <div style="background-color: white; border-style:solid; border-color:lightgrey; border-width:2px; width:100px; height:50px">
            <i class='prevNav glyphicon glyphicon-chevron-left'  style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black;"></i>
        </div>
    </a>
  </li>
</ul>

  
<ul>
  <li id="relations-next" style="opacity:0.4" onmouseover="mouseOverNext()" onmouseout="mouseOutNext()" class="navLink" title='Next Section - 14.5. The set class' data-toggle="tooltip" >
    <a href="set.html" aria-label="14.5. The set class">
      <div style="background-color: white; border-style:solid; border-color:lightgrey; border-width:2px; width:100px; height:50px">
          <i id="relationsNextIcon" class='nextNav glyphicon glyphicon-chevron-right' style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black; "></i>
      </div>
    </a>
  </li>
</ul>

<script type="text/javascript">

  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});

</script>

<script>
	function mouseOverPrev() {
		document.getElementById("relations-prev").style.opacity=1;
	}

	function mouseOutPrev() {
		document.getElementById("relations-prev").style.opacity=0.4;
	}
	function mouseOverNext() {
		document.getElementById("relations-next").style.opacity=1;
	}

	function mouseOutNext() {
		document.getElementById("relations-next").style.opacity=0.4;
	}
</script>
  
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2022 Dave Parillo.
      Created using <a href="http://runestoneinteractive.org/">Runestone</a> 5.5.5.
    </p>
  </div>
</footer>




<script> getSwitch(); </script>


  </body>
</html>